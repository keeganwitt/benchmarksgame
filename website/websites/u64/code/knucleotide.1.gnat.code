<span class="hl slc">--  The Computer Language Benchmarks Game</span>
<span class="hl slc">--  http://benchmarksgame.alioth.debian.org/</span>
<span class="hl slc">--</span>
<span class="hl slc">--  Contributed by Martin Krischik</span>
<span class="hl slc">--  Modified by Georg Bauhaus and Jonathan Parker (Oct 2012)</span>

<span class="hl slc">--  Uses representation for compacting. Idea for uppercasing on the</span>
<span class="hl slc">--  fly taken from Rikard Mustaj√§rvi's Java program.</span>

<span class="hl kwa">pragma</span> Profile <span class="hl opt">(</span>Ravenscar<span class="hl opt">);</span>

<span class="hl kwa">with</span> Data_Input<span class="hl opt">;</span>          <span class="hl kwa">use</span> Data_Input<span class="hl opt">;</span>
<span class="hl kwa">with</span> Data<span class="hl opt">;</span>                <span class="hl kwa">use</span> Data<span class="hl opt">;</span>
<span class="hl kwa">with</span> Statistics<span class="hl opt">.</span>Setup<span class="hl opt">;</span>    <span class="hl kwa">use</span> Statistics<span class="hl opt">;</span>
<span class="hl kwa">with</span> Statistics<span class="hl opt">.</span>Aux<span class="hl opt">;</span>
<span class="hl kwa">with</span> GNAT<span class="hl opt">.</span>OS_Lib<span class="hl opt">;</span>

<span class="hl kwa">procedure</span> KNucleotide <span class="hl kwa">is</span>
   Input_Text <span class="hl opt">:</span> Writable_String_Access<span class="hl opt">;</span>
<span class="hl kwa">begin</span>
   Input_Text  <span class="hl opt">:=</span> <span class="hl kwa">new</span> <span class="hl kwb">String</span><span class="hl str">'(Read);</span>
<span class="hl str">   Setup.Buffer := To_Compressed (Plain_View (Input_Text));</span>
<span class="hl str">   Free (Input_Text);</span>
<span class="hl str"></span>
<span class="hl str">   Aux.Unlock;</span>
<span class="hl str">   Aux.Print_When_Finished;</span>
<span class="hl str"></span>
<span class="hl str">   GNAT.OS_Lib.OS_Exit (0);</span>
<span class="hl str">end KNucleotide;</span>
<span class="hl str"></span>
<span class="hl str">package Statistics is</span>
<span class="hl str">   pragma Pure;</span>
<span class="hl str">   type Fragment_Lengths is range 1 .. 18;</span>
<span class="hl str">end Statistics;</span>
<span class="hl str"></span>
<span class="hl str">with Statistics.Work;</span>
<span class="hl str">with Data.Text_Fragments;</span>
<span class="hl str">with Interfaces;</span>
<span class="hl str">with Ada.Unchecked_Conversion;</span>
<span class="hl str">package Statistics.Setup is</span>
<span class="hl str"></span>
<span class="hl str">   generic function UC renames Ada.Unchecked_Conversion;</span>
<span class="hl str"></span>
<span class="hl str">   subtype U8 is Interfaces.Unsigned_8;</span>
<span class="hl str">   subtype U16 is Interfaces.Unsigned_16;</span>
<span class="hl str">   subtype U32 is Interfaces.Unsigned_32;</span>
<span class="hl str">   subtype U64 is Interfaces.Unsigned_64;</span>
<span class="hl str"></span>
<span class="hl str">   type F is array (Fragment_Lengths range &lt;&gt;) of Data.Symbol;</span>
<span class="hl str">   for F'Component_Size use Data.Symbol'Size;</span>
<span class="hl str"></span>
<span class="hl str">   subtype FX1 is Fragment_Lengths range 1 .. 1;</span>
<span class="hl str">   type F1 is new F (FX1);</span>
<span class="hl str">   for F1'Size use U8'Size;</span>
<span class="hl str">   function To_U is new UC (F1, U8);</span>
<span class="hl str"></span>
<span class="hl str">   subtype FX2 is Fragment_Lengths range 1 .. 2;</span>
<span class="hl str">   type F2 is new F (FX2);</span>
<span class="hl str">   for F2'Size use U8'Size;</span>
<span class="hl str">   function To_U is new UC (F2, U8);</span>
<span class="hl str"></span>
<span class="hl str">   subtype FX3 is Fragment_Lengths range 1 .. 3;</span>
<span class="hl str">   type F3 is new F (FX3);</span>
<span class="hl str">   for F3'Size use U8'Size;</span>
<span class="hl str">   function To_U is new UC (F3, U8);</span>
<span class="hl str"></span>
<span class="hl str">   subtype FX4 is Fragment_Lengths range 1 .. 4;</span>
<span class="hl str">   type F4 is new F (FX4);</span>
<span class="hl str">   for F4'Size use U8'Size;</span>
<span class="hl str">   function To_U is new UC (F4, U8);</span>
<span class="hl str"></span>
<span class="hl str">   subtype FX6 is Fragment_Lengths range 1 .. 6;</span>
<span class="hl str">   type F6 is new F (FX6);</span>
<span class="hl str">   for F6'Size use U16'Size;</span>
<span class="hl str">   function To_U is new UC (F6, U16);</span>
<span class="hl str"></span>
<span class="hl str">   subtype FX12 is Fragment_Lengths range 1 .. 12;</span>
<span class="hl str">   type F12 is new F (FX12);</span>
<span class="hl str">   for F12'Size use U32'Size;</span>
<span class="hl str">   function To_U is new UC (F12, U32);</span>
<span class="hl str"></span>
<span class="hl str">   subtype FX18 is Fragment_Lengths range 1 .. 18;</span>
<span class="hl str">   type F18 is new F (FX18);</span>
<span class="hl str">   for F18'Size use U64'Size;</span>
<span class="hl str">   function To_U is new UC (F18, U64);</span>
<span class="hl str"></span>
<span class="hl str">   package Fragments_1 is new Data.Text_Fragments (FX1, F1, U8);</span>
<span class="hl str">   package Fragments_2 is new Data.Text_Fragments (FX2, F2, U8);</span>
<span class="hl str">   package Fragments_3 is new Data.Text_Fragments (FX3, F3, U8);</span>
<span class="hl str">   package Fragments_4 is new Data.Text_Fragments (FX4, F4, U8);</span>
<span class="hl str">   package Fragments_6 is new Data.Text_Fragments (FX6, F6, U16);</span>
<span class="hl str">   package Fragments_12 is new Data.Text_Fragments (FX12, F12, U32);</span>
<span class="hl str">   package Fragments_18 is new Data.Text_Fragments (FX18, F18, U64);</span>
<span class="hl str"></span>
<span class="hl str">   package Work_On_1 is new Work (Fragments_1);</span>
<span class="hl str">   package Work_On_2 is new Work (Fragments_2);</span>
<span class="hl str">   package Work_On_3 is new Work (Fragments_3);</span>
<span class="hl str">   package Work_On_4 is new Work (Fragments_4);</span>
<span class="hl str">   package Work_On_6 is new Work (Fragments_6);</span>
<span class="hl str">   package Work_On_12 is new Work (Fragments_12);</span>
<span class="hl str">   package Work_On_18 is new Work (Fragments_18);</span>
<span class="hl str"></span>
<span class="hl str">   Buffer : aliased Data.Compressed_View;</span>
<span class="hl str"></span>
<span class="hl str">   Worker_1 : Work_On_1.Counting_Job (Buffer'Access, 1, null);</span>
<span class="hl str">   Worker_2 : Work_On_2.Counting_Job (Buffer'Access, 2, null);</span>
<span class="hl str">   Worker_3 : Work_On_3.Counting_Job (Buffer'Access, 3, new F3'</span><span class="hl opt">(</span><span class="hl str">&quot;GGT&quot;</span><span class="hl opt">));</span>
   Worker_4 <span class="hl opt">:</span> Work_On_4<span class="hl opt">.</span>Counting_Job <span class="hl opt">(</span>Buffer<span class="hl kwd">'Access</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl kwa">new</span> F4<span class="hl str">'(&quot;GGTA&quot;));</span>
<span class="hl str">   Worker_6 : Work_On_6.Counting_Job (Buffer'Access, 6, new F6'</span><span class="hl opt">(</span><span class="hl str">&quot;GGTATT&quot;</span><span class="hl opt">));</span>
   Worker_12 <span class="hl opt">:</span> Work_On_12<span class="hl opt">.</span>Counting_Job
     <span class="hl opt">(</span>Buffer<span class="hl kwd">'Access</span><span class="hl opt">,</span> <span class="hl num">12</span><span class="hl opt">,</span> <span class="hl kwa">new</span> F12<span class="hl str">'(&quot;GGTATTTTAATT&quot;));</span>
<span class="hl str">   Worker_18 : Work_On_18.Counting_Job</span>
<span class="hl str">     (Buffer'Access, 18, new F18'</span><span class="hl opt">(</span><span class="hl str">&quot;GGTATTTTAATTTATAGT&quot;</span><span class="hl opt">));</span>

<span class="hl kwa">end</span> Statistics<span class="hl opt">.</span>Setup<span class="hl opt">;</span>

<span class="hl kwa">package</span> Data <span class="hl kwa">is</span>

   <span class="hl kwa">pragma</span> Preelaborate <span class="hl opt">(</span>Data<span class="hl opt">);</span>

   <span class="hl kwa">type</span> Symbol <span class="hl kwa">is</span> <span class="hl opt">(</span><span class="hl str">'A'</span><span class="hl opt">,</span> <span class="hl str">'C'</span><span class="hl opt">,</span> <span class="hl str">'G'</span><span class="hl opt">,</span> <span class="hl str">'T'</span><span class="hl opt">);</span>
   <span class="hl kwa">for</span> Symbol<span class="hl kwd">'Size</span> <span class="hl kwa">use</span> <span class="hl num">2</span><span class="hl opt">;</span>

   <span class="hl kwa">type</span> Compressed <span class="hl kwa">is array</span> <span class="hl opt">(</span><span class="hl kwb">Positive</span> <span class="hl kwa">range</span> <span class="hl opt">&lt;&gt;)</span> <span class="hl kwa">of</span> Symbol<span class="hl opt">;</span>
   <span class="hl kwa">for</span> Compressed<span class="hl kwd">'Component_Size</span> <span class="hl kwa">use</span> Symbol<span class="hl kwd">'Size</span><span class="hl opt">;</span>

   <span class="hl kwa">type</span> Translation_Table <span class="hl kwa">is array</span> <span class="hl opt">(</span><span class="hl kwb">Character</span> <span class="hl kwa">range</span> <span class="hl opt">&lt;&gt;)</span> <span class="hl kwa">of</span> Symbol<span class="hl opt">;</span>
   To_Symbol <span class="hl opt">:</span> <span class="hl kwa">constant</span> Translation_Table <span class="hl opt">(</span><span class="hl str">'A'</span> <span class="hl opt">..</span> <span class="hl str">'t'</span><span class="hl opt">) :=</span>
     <span class="hl opt">(</span><span class="hl str">'A'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'A'</span><span class="hl opt">,</span> <span class="hl str">'a'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'A'</span><span class="hl opt">,</span>
      <span class="hl str">'C'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'C'</span><span class="hl opt">,</span> <span class="hl str">'c'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'C'</span><span class="hl opt">,</span>
      <span class="hl str">'G'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'G'</span><span class="hl opt">,</span> <span class="hl str">'g'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'G'</span><span class="hl opt">,</span>
      <span class="hl str">'T'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'T'</span><span class="hl opt">,</span> <span class="hl str">'t'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'T'</span><span class="hl opt">,</span> <span class="hl kwa">others</span> <span class="hl opt">=&gt;</span> <span class="hl str">'A'</span><span class="hl opt">);</span>

   <span class="hl kwa">type</span> Elbat_Noitalsnart <span class="hl kwa">is array</span> <span class="hl opt">(</span>Symbol <span class="hl kwa">range</span> <span class="hl opt">&lt;&gt;)</span> <span class="hl kwa">of</span> <span class="hl kwb">Character</span><span class="hl opt">;</span>
   To_Character <span class="hl opt">:</span> <span class="hl kwa">constant</span> Elbat_Noitalsnart <span class="hl opt">(</span><span class="hl str">'A'</span> <span class="hl opt">..</span> <span class="hl str">'T'</span><span class="hl opt">) :=</span>
     <span class="hl opt">(</span><span class="hl str">'A'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'A'</span><span class="hl opt">,</span>
      <span class="hl str">'C'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'C'</span><span class="hl opt">,</span>
      <span class="hl str">'G'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'G'</span><span class="hl opt">,</span>
      <span class="hl str">'T'</span> <span class="hl opt">=&gt;</span> <span class="hl str">'T'</span><span class="hl opt">);</span>

   <span class="hl kwa">type</span> Plain_View <span class="hl kwa">is access constant</span> <span class="hl kwb">String</span><span class="hl opt">;</span>
   <span class="hl kwa">type</span> Compressed_View <span class="hl kwa">is access constant</span> Compressed<span class="hl opt">;</span>

   <span class="hl kwa">function</span> To_Compressed <span class="hl opt">(</span>Buffer <span class="hl opt">:</span> Plain_View<span class="hl opt">)</span> <span class="hl kwa">return</span> Compressed_View<span class="hl opt">;</span>

<span class="hl kwa">end</span> Data<span class="hl opt">;</span>

<span class="hl kwa">package body</span> Data <span class="hl kwa">is</span>

   <span class="hl kwa">type</span> Compressed_Access <span class="hl kwa">is access</span> Compressed<span class="hl opt">;</span>

   <span class="hl kwa">function</span> To_Compressed <span class="hl opt">(</span>Buffer <span class="hl opt">:</span> Plain_View<span class="hl opt">)</span> <span class="hl kwa">return</span> Compressed_View <span class="hl kwa">is</span>
      Result <span class="hl opt">:</span> <span class="hl kwa">constant</span> Compressed_Access <span class="hl opt">:=</span> <span class="hl kwa">new</span> Compressed <span class="hl opt">(</span>Buffer<span class="hl kwd">'Range</span><span class="hl opt">);</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">for</span> K <span class="hl kwa">in</span> Buffer<span class="hl kwd">'Range</span> <span class="hl kwa">loop</span>
         Result <span class="hl opt">(</span>K<span class="hl opt">) :=</span> To_Symbol <span class="hl opt">(</span>Buffer <span class="hl opt">(</span>K<span class="hl opt">));</span>
      <span class="hl kwa">end loop</span><span class="hl opt">;</span>
      <span class="hl kwa">return</span> Compressed_View <span class="hl opt">(</span>Result<span class="hl opt">);</span>
   <span class="hl kwa">end</span> To_Compressed<span class="hl opt">;</span>

<span class="hl kwa">end</span> Data<span class="hl opt">;</span>

<span class="hl kwa">with</span> Statistics<span class="hl opt">;</span>    <span class="hl kwa">use</span> Statistics<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Containers<span class="hl opt">;</span>
<span class="hl kwa">generic</span>
   <span class="hl kwa">type</span> Fragment_Index <span class="hl kwa">is new</span> Fragment_Lengths<span class="hl opt">;</span>
   <span class="hl kwa">type</span> Compact <span class="hl kwa">is array</span> <span class="hl opt">(</span>Fragment_Index<span class="hl opt">)</span> <span class="hl kwa">of</span> Symbol<span class="hl opt">;</span>
   <span class="hl kwa">type</span> Rep_Type <span class="hl kwa">is mod</span> <span class="hl opt">&lt;&gt;;</span>
   <span class="hl kwa">with function</span> To_U <span class="hl opt">(</span>S <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> Rep_Type <span class="hl kwa">is</span> <span class="hl opt">&lt;&gt;;</span>
<span class="hl kwa">package</span> Data<span class="hl opt">.</span>Text_Fragments <span class="hl kwa">is</span>

   <span class="hl kwa">pragma</span> Preelaborate <span class="hl opt">(</span>Text_Fragments<span class="hl opt">);</span>

   <span class="hl kwa">type</span> Fragment <span class="hl kwa">is array</span> <span class="hl opt">(</span>Fragment_Index<span class="hl opt">)</span> <span class="hl kwa">of</span> <span class="hl kwb">Character</span><span class="hl opt">;</span>

   <span class="hl kwa">function</span> Hash <span class="hl opt">(</span>Key <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> Ada<span class="hl opt">.</span>Containers<span class="hl opt">.</span>Hash_Type<span class="hl opt">;</span>
   <span class="hl kwa">function</span> Eq <span class="hl opt">(</span>Left<span class="hl opt">,</span> Right <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Boolean</span><span class="hl opt">;</span>
   <span class="hl kwa">function</span> <span class="hl str">&quot;=&quot;</span> <span class="hl opt">(</span>Left<span class="hl opt">,</span> Right <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Boolean</span> <span class="hl kwa">is abstract</span><span class="hl opt">;</span>

   <span class="hl kwa">function</span> To_Fragment <span class="hl opt">(</span>Source <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> Fragment<span class="hl opt">;</span>

<span class="hl kwa">end</span> Data<span class="hl opt">.</span>Text_Fragments<span class="hl opt">;</span>

<span class="hl kwa">package body</span> Data<span class="hl opt">.</span>Text_Fragments <span class="hl kwa">is</span>

   Size <span class="hl opt">:</span> <span class="hl kwa">constant</span> Fragment_Index <span class="hl opt">:=</span> Fragment_Index<span class="hl kwd">'Last</span><span class="hl opt">;</span>

   <span class="hl kwa">function</span> Hash <span class="hl opt">(</span>Key <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> Ada<span class="hl opt">.</span>Containers<span class="hl opt">.</span>Hash_Type <span class="hl kwa">is</span>
      <span class="hl kwa">subtype</span> HT <span class="hl kwa">is</span> Ada<span class="hl opt">.</span>Containers<span class="hl opt">.</span>Hash_Type<span class="hl opt">;</span>
      <span class="hl kwa">pragma</span> Assert <span class="hl opt">(</span>HT<span class="hl kwd">'Size</span> <span class="hl opt">&lt;=</span> <span class="hl num">32</span><span class="hl opt">);</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">if</span>    Size <span class="hl opt">&lt;=</span>  <span class="hl num">4</span> <span class="hl kwa">then return</span> HT <span class="hl opt">(</span>To_U <span class="hl opt">(</span>Key<span class="hl opt">)</span> <span class="hl kwa">and</span> <span class="hl num">16</span>#FF#<span class="hl opt">);</span>
      <span class="hl kwa">elsif</span> Size <span class="hl opt">&lt;=</span>  <span class="hl num">8</span> <span class="hl kwa">then return</span> HT <span class="hl opt">(</span>To_U <span class="hl opt">(</span>Key<span class="hl opt">)</span> <span class="hl kwa">and</span> <span class="hl num">16</span>#FFFF#<span class="hl opt">);</span>
      <span class="hl kwa">elsif</span> Size <span class="hl opt">&lt;=</span> <span class="hl num">16</span> <span class="hl kwa">then return</span> HT <span class="hl opt">(</span>To_U <span class="hl opt">(</span>Key<span class="hl opt">));</span>
      <span class="hl kwa">else</span>
         <span class="hl kwa">return</span> HT <span class="hl opt">(</span>To_U <span class="hl opt">(</span>Key<span class="hl opt">)</span> <span class="hl kwa">and</span> <span class="hl num">16</span>#FFFF_FFFF#<span class="hl opt">);</span>
      <span class="hl kwa">end if</span><span class="hl opt">;</span>
   <span class="hl kwa">end</span> Hash<span class="hl opt">;</span>

   <span class="hl kwa">function</span> Eq <span class="hl opt">(</span>Left<span class="hl opt">,</span> Right <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Boolean</span> <span class="hl kwa">is</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">if</span>    Size <span class="hl opt">&lt;=</span>  <span class="hl num">4</span> <span class="hl kwa">then</span>
         <span class="hl kwa">return</span> <span class="hl opt">(</span>To_U <span class="hl opt">(</span>Left<span class="hl opt">)</span> <span class="hl kwa">and</span> <span class="hl num">16</span>#FF#<span class="hl opt">) = (</span>To_U <span class="hl opt">(</span>Right<span class="hl opt">)</span> <span class="hl kwa">and</span> <span class="hl num">16</span>#FF#<span class="hl opt">);</span>
      <span class="hl kwa">elsif</span> Size <span class="hl opt">&lt;=</span>  <span class="hl num">8</span> <span class="hl kwa">then</span>
         <span class="hl kwa">return</span> <span class="hl opt">(</span>To_U <span class="hl opt">(</span>Left<span class="hl opt">)</span> <span class="hl kwa">and</span> <span class="hl num">16</span>#FFFF#<span class="hl opt">) = (</span>To_U <span class="hl opt">(</span>Right<span class="hl opt">)</span> <span class="hl kwa">and</span> <span class="hl num">16</span>#FFFF#<span class="hl opt">);</span>
      <span class="hl kwa">elsif</span> Size <span class="hl opt">&lt;=</span> <span class="hl num">16</span> <span class="hl kwa">then</span>
         <span class="hl kwa">return</span> To_U <span class="hl opt">(</span>Left<span class="hl opt">) =</span> To_U <span class="hl opt">(</span>Right<span class="hl opt">);</span>
      <span class="hl kwa">else</span>
         <span class="hl kwa">return</span> To_U <span class="hl opt">(</span>Left<span class="hl opt">) =</span> To_U <span class="hl opt">(</span>Right<span class="hl opt">);</span>
      <span class="hl kwa">end if</span><span class="hl opt">;</span>
   <span class="hl kwa">end</span> Eq<span class="hl opt">;</span>

   <span class="hl kwa">function</span> To_Fragment <span class="hl opt">(</span>Source <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> Fragment <span class="hl kwa">is</span>
      Result <span class="hl opt">:</span> Fragment<span class="hl opt">;</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">for</span> K <span class="hl kwa">in</span> Source<span class="hl kwd">'Range</span> <span class="hl kwa">loop</span>
         Result <span class="hl opt">(</span>K<span class="hl opt">) :=</span> To_Character <span class="hl opt">(</span>Source <span class="hl opt">(</span>K<span class="hl opt">));</span>
      <span class="hl kwa">end loop</span><span class="hl opt">;</span>
      <span class="hl kwa">return</span> Result<span class="hl opt">;</span>
   <span class="hl kwa">end</span> To_Fragment<span class="hl opt">;</span>

<span class="hl kwa">end</span> Data<span class="hl opt">.</span>Text_Fragments<span class="hl opt">;</span>

<span class="hl kwa">with</span> Data<span class="hl opt">.</span>Text_Fragments<span class="hl opt">;</span>
<span class="hl kwa">generic</span>
   <span class="hl kwa">with package</span> Fragments <span class="hl kwa">is new</span> Data<span class="hl opt">.</span>Text_Fragments <span class="hl opt">(&lt;&gt;);</span>
<span class="hl kwa">package</span> Statistics<span class="hl opt">.</span>Calculator <span class="hl kwa">is</span>

   <span class="hl kwa">use</span> Fragments<span class="hl opt">;</span>

   <span class="hl slc">--  Elements used to store inside hash table:</span>

   <span class="hl kwa">type</span> Element_Type <span class="hl kwa">is private</span><span class="hl opt">;</span>
   <span class="hl kwa">type</span> Element_Access <span class="hl kwa">is access</span> Element_Type<span class="hl opt">;</span>
   <span class="hl kwa">for</span> Element_Access<span class="hl kwd">'Storage_Size</span> <span class="hl kwa">use</span> <span class="hl num">16</span>#<span class="hl num">40</span>_00_00#<span class="hl opt">;</span>

   <span class="hl slc">--  Iteration:</span>

   <span class="hl kwa">function</span> Get_First <span class="hl kwa">return</span> Element_Access<span class="hl opt">;</span>
   <span class="hl kwa">function</span> Get_Next <span class="hl kwa">return</span> Element_Access<span class="hl opt">;</span>

   <span class="hl slc">--  Key and value:</span>

   <span class="hl kwa">function</span> Count_Of <span class="hl opt">(</span>Element <span class="hl opt">:</span> <span class="hl kwa">not null</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Natural</span><span class="hl opt">;</span>
   <span class="hl kwa">function</span> Fragment_Of <span class="hl opt">(</span>Element <span class="hl opt">:</span> <span class="hl kwa">not null</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> Compact<span class="hl opt">;</span>

   <span class="hl slc">--  Calculate frequency of occurrences of the nucleotides:</span>

   <span class="hl kwa">procedure</span> Get_Frequencies_Big <span class="hl opt">(</span>Buffer <span class="hl opt">:</span> Data<span class="hl opt">.</span>Compressed<span class="hl opt">);</span>
   <span class="hl kwa">procedure</span> Get_Frequencies_Small <span class="hl opt">(</span>Buffer <span class="hl opt">:</span> Data<span class="hl opt">.</span>Compressed<span class="hl opt">);</span>

   <span class="hl kwa">function</span> Occurrences <span class="hl opt">(</span>Nucleotide_Fragment <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Natural</span><span class="hl opt">;</span>
   <span class="hl kwa">procedure</span> Get_Totals <span class="hl opt">(</span>Total <span class="hl opt">:</span> <span class="hl kwa">out</span> <span class="hl kwb">Natural</span><span class="hl opt">;</span> Count <span class="hl opt">:</span> <span class="hl kwa">out</span> <span class="hl kwb">Natural</span><span class="hl opt">);</span>

<span class="hl kwa">private</span>
   <span class="hl kwa">type</span> Element_Type <span class="hl kwa">is record</span>
      Count <span class="hl opt">:</span> <span class="hl kwb">Natural</span> <span class="hl opt">:=</span> <span class="hl num">0</span><span class="hl opt">;</span>
      Key   <span class="hl opt">:</span> Compact<span class="hl opt">;</span>
      Next  <span class="hl opt">:</span> Element_Access<span class="hl opt">;</span>
   <span class="hl kwa">end record</span><span class="hl opt">;</span>
<span class="hl kwa">end</span> Statistics<span class="hl opt">.</span>Calculator<span class="hl opt">;</span>

<span class="hl kwa">with</span> GNAT<span class="hl opt">.</span>HTable<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Containers<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Unchecked_Conversion<span class="hl opt">;</span>
<span class="hl kwa">with</span> Interfaces<span class="hl opt">;</span>

<span class="hl kwa">package body</span> Statistics<span class="hl opt">.</span>Calculator <span class="hl kwa">is</span>

   <span class="hl slc">--  Prepare table.</span>

   Log_Table_Size <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">Natural</span> <span class="hl opt">:=</span>
     <span class="hl kwb">Natural</span><span class="hl kwd">'Min</span> <span class="hl opt">(</span><span class="hl kwb">Natural</span> <span class="hl opt">(</span>Fragment<span class="hl kwd">'Last</span><span class="hl opt">) *</span> <span class="hl num">2</span> <span class="hl opt">+</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">17</span><span class="hl opt">);</span>

   Table_Size     <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">Natural</span> <span class="hl opt">:=</span> <span class="hl num">2</span> <span class="hl opt">**</span> Log_Table_Size<span class="hl opt">;</span>

   <span class="hl kwa">subtype</span> Hash_Type <span class="hl kwa">is</span> <span class="hl kwb">Natural</span> <span class="hl kwa">range</span> <span class="hl num">0</span> <span class="hl opt">..</span> Table_Size <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">;</span>

   <span class="hl kwa">function</span> Hash <span class="hl opt">(</span>Key <span class="hl opt">:</span> Compact<span class="hl opt">)</span> <span class="hl kwa">return</span> Hash_Type <span class="hl kwa">is</span>
      <span class="hl kwa">use type</span> Ada<span class="hl opt">.</span>Containers<span class="hl opt">.</span>Hash_Type<span class="hl opt">;</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">return</span> Hash_Type <span class="hl opt">(</span>Fragments<span class="hl opt">.</span>Hash <span class="hl opt">(</span>Key<span class="hl opt">)</span>
                           <span class="hl kwa">mod</span> Ada<span class="hl opt">.</span>Containers<span class="hl opt">.</span>Hash_Type <span class="hl opt">(</span>Table_Size<span class="hl opt">));</span>
   <span class="hl kwa">end</span> Hash<span class="hl opt">;</span>

   <span class="hl kwa">function</span> Next <span class="hl opt">(</span>E <span class="hl opt">:</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> Element_Access <span class="hl kwa">is</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">return</span> E<span class="hl opt">.</span><span class="hl kwa">all</span><span class="hl opt">.</span>Next<span class="hl opt">;</span>
   <span class="hl kwa">end</span> Next<span class="hl opt">;</span>

   <span class="hl kwa">procedure</span> Set_Next <span class="hl opt">(</span>E <span class="hl opt">:</span> Element_Access<span class="hl opt">;</span> Next_Element <span class="hl opt">:</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">is</span>
   <span class="hl kwa">begin</span>
      E<span class="hl opt">.</span><span class="hl kwa">all</span><span class="hl opt">.</span>Next <span class="hl opt">:=</span> Next_Element<span class="hl opt">;</span>
   <span class="hl kwa">end</span> Set_Next<span class="hl opt">;</span>

   <span class="hl kwa">function</span> Get_Key <span class="hl opt">(</span>E <span class="hl opt">:</span> <span class="hl kwa">not null</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> Compact <span class="hl kwa">is</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">return</span> E<span class="hl opt">.</span><span class="hl kwa">all</span><span class="hl opt">.</span>Key<span class="hl opt">;</span>
   <span class="hl kwa">end</span> Get_Key<span class="hl opt">;</span>

   <span class="hl kwa">package</span> Table <span class="hl kwa">is new</span> GNAT<span class="hl opt">.</span>HTable<span class="hl opt">.</span>Static_HTable
     <span class="hl opt">(</span>Header_Num <span class="hl opt">=&gt;</span> Hash_Type<span class="hl opt">,</span>
      Element    <span class="hl opt">=&gt;</span> Element_Type<span class="hl opt">,</span>
      Elmt_Ptr   <span class="hl opt">=&gt;</span> Element_Access<span class="hl opt">,</span>
      Null_Ptr   <span class="hl opt">=&gt;</span> <span class="hl kwa">null</span><span class="hl opt">,</span>
      Key        <span class="hl opt">=&gt;</span> Compact<span class="hl opt">,</span>
      Hash       <span class="hl opt">=&gt;</span> Hash<span class="hl opt">,</span>
      Equal      <span class="hl opt">=&gt;</span> Fragments<span class="hl opt">.</span>Eq<span class="hl opt">,</span>
      Set_Next   <span class="hl opt">=&gt;</span> Set_Next<span class="hl opt">,</span>
      Next       <span class="hl opt">=&gt;</span> Next<span class="hl opt">,</span>
      Get_Key    <span class="hl opt">=&gt;</span> Get_Key<span class="hl opt">);</span>

   <span class="hl slc">--  Counting</span>

   <span class="hl kwa">function</span> To_Compact <span class="hl kwa">is new</span> Ada<span class="hl opt">.</span>Unchecked_Conversion <span class="hl opt">(</span>Rep_Type<span class="hl opt">,</span> Compact<span class="hl opt">);</span>

   Bits_per_Fragment <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">Positive</span> <span class="hl opt">:=</span>
     Data<span class="hl opt">.</span>Symbol<span class="hl kwd">'Size</span> <span class="hl opt">*</span> Fragments<span class="hl opt">.</span>Compact<span class="hl kwd">'Length</span><span class="hl opt">;</span>

   <span class="hl kwa">generic</span>
      <span class="hl kwa">type</span> U <span class="hl kwa">is mod</span> <span class="hl opt">&lt;&gt;;</span>
   <span class="hl kwa">procedure</span> TAdd <span class="hl opt">(</span>Value <span class="hl opt">:</span> U<span class="hl opt">);</span>
   <span class="hl kwa">procedure</span> TAdd <span class="hl opt">(</span>Value <span class="hl opt">:</span> U<span class="hl opt">)</span> <span class="hl kwa">is</span>
      Key <span class="hl opt">:</span> <span class="hl kwa">constant</span> Compact <span class="hl opt">:=</span> To_Compact <span class="hl opt">(</span>Rep_Type <span class="hl opt">(</span>Value<span class="hl opt">));</span>
      Element <span class="hl opt">:</span> <span class="hl kwa">constant</span> Element_Access <span class="hl opt">:=</span> Table<span class="hl opt">.</span>Get <span class="hl opt">(</span>Key<span class="hl opt">);</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">if</span> Element <span class="hl opt">/=</span> <span class="hl kwa">null then</span>
         Element<span class="hl opt">.</span><span class="hl kwa">all</span><span class="hl opt">.</span>Count <span class="hl opt">:=</span> <span class="hl kwb">Natural</span><span class="hl kwd">'Succ</span> <span class="hl opt">(</span>Element<span class="hl opt">.</span><span class="hl kwa">all</span><span class="hl opt">.</span>Count<span class="hl opt">);</span>
      <span class="hl kwa">else</span>
         Table<span class="hl opt">.</span>Set <span class="hl opt">(</span><span class="hl kwa">new</span> Element_Type<span class="hl str">'(Count =&gt; 1,</span>
<span class="hl str">                                      Key =&gt; Key,</span>
<span class="hl str">                                      Next =&gt; null));</span>
<span class="hl str">      end if;</span>
<span class="hl str">   end TAdd;</span>
<span class="hl str"></span>
<span class="hl str">   generic</span>
<span class="hl str">      type U is mod &lt;&gt;;</span>
<span class="hl str">      with function Shift_Left (Value : U; Amount : Natural) return U is &lt;&gt;;</span>
<span class="hl str">      with function Shift_Right (Value : U; Amount : Natural) return U is &lt;&gt;;</span>
<span class="hl str">   procedure Get_Frequencies (Buffer : Data.Compressed);</span>
<span class="hl str">   procedure Get_Frequencies (Buffer : Data.Compressed) is</span>
<span class="hl str"></span>
<span class="hl str">      procedure Add_to_Table is new TAdd (U);</span>
<span class="hl str"></span>
<span class="hl str">      S : constant          := Data.Symbol'Size;</span>
<span class="hl str">      W : constant Positive := U'Size / 16 - 1;</span>
<span class="hl str">      Symbols_per_U : constant Positive := U'Size / S;</span>
<span class="hl str">      No_of_U       : constant Natural  := (S * Buffer'Length) /  U'Size;</span>
<span class="hl str">      Mask          : constant U        := 2**Bits_per_Fragment - 1;</span>
<span class="hl str"></span>
<span class="hl str">      Overlay       : array (1 .. No_of_U) of U;</span>
<span class="hl str">      pragma Import (Ada, Overlay);</span>
<span class="hl str">      for Overlay'Address use Buffer (Buffer'First)'Address;</span>
<span class="hl str">      Bits          : U;</span>
<span class="hl str">   begin</span>
<span class="hl str">      Bits := Overlay (Overlay'First);</span>
<span class="hl str">      for K in  2 .. Overlay'Last  loop</span>
<span class="hl str">         for HW in 0 .. W loop</span>
<span class="hl str">            for j in 1 .. 16/S loop</span>
<span class="hl str">               Add_to_Table (Bits and Mask);</span>
<span class="hl str">               Bits := Shift_Right (Bits, S);</span>
<span class="hl str">            end loop;</span>
<span class="hl str">            Bits := Shift_Left (Shift_Right (Overlay (K), HW * 16),</span>
<span class="hl str">                                W * 16) or Bits;</span>
<span class="hl str">         end loop;</span>
<span class="hl str">      end loop;</span>
<span class="hl str"></span>
<span class="hl str">      for j in 1 .. Symbols_per_U - Compact'Length + 1 loop</span>
<span class="hl str">         Add_to_Table (Bits and Mask);</span>
<span class="hl str">         Bits := Shift_Right (Bits, S);</span>
<span class="hl str">      end loop;</span>
<span class="hl str"></span>
<span class="hl str">      for k in Symbols_per_U * No_of_U + 1 - Compact'Length + 1</span>
<span class="hl str">        .. Buffer'Length - Compact'Length + 1</span>
<span class="hl str">      loop</span>
<span class="hl str">         Add_to_Table (U (Fragments.To_U</span>
<span class="hl str">                           (Compact (Buffer (k .. k + Compact'Length - 1)))));</span>
<span class="hl str">      end loop;</span>
<span class="hl str">   end Get_Frequencies;</span>
<span class="hl str"></span>
<span class="hl str">   use Interfaces;</span>
<span class="hl str">   procedure FSmall is new Get_Frequencies (Unsigned_32);</span>
<span class="hl str">   procedure FBig is new Get_Frequencies (Unsigned_64);</span>
<span class="hl str"></span>
<span class="hl str">   procedure Get_Frequencies_Small (Buffer : Data.Compressed) renames FSmall;</span>
<span class="hl str">   procedure Get_Frequencies_Big (Buffer : Data.Compressed) renames FBig;</span>
<span class="hl str"></span>
<span class="hl str">   function Count_Of (Element : not null Element_Access) return Natural is</span>
<span class="hl str">   begin</span>
<span class="hl str">      return Element.all.Count;</span>
<span class="hl str">   end Count_Of;</span>
<span class="hl str"></span>
<span class="hl str">   function Occurrences (Nucleotide_Fragment : Compact) return Natural is</span>
<span class="hl str">      The_Element : constant Element_Access := Table.Get (Nucleotide_Fragment);</span>
<span class="hl str">   begin</span>
<span class="hl str">      if The_Element /= null then</span>
<span class="hl str">         return The_Element.all.Count;</span>
<span class="hl str">      else</span>
<span class="hl str">         return 0;</span>
<span class="hl str">      end if;</span>
<span class="hl str">   end Occurrences;</span>
<span class="hl str"></span>
<span class="hl str">   function Get_First return Element_Access renames Table.Get_First;</span>
<span class="hl str">   function Get_Next return Element_Access renames Table.Get_Next;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Get_Totals (Total : out Natural; Count : out Natural) is</span>
<span class="hl str">      The_Element : Element_Access := Table.Get_First;</span>
<span class="hl str">   begin</span>
<span class="hl str">      Total := 0;</span>
<span class="hl str">      Count := 0;</span>
<span class="hl str">      while The_Element /= null loop</span>
<span class="hl str">         Total       := Total + The_Element.all.Count;</span>
<span class="hl str">         Count       := Count + 1;</span>
<span class="hl str">         The_Element := Table.Get_Next;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">   end Get_Totals;</span>
<span class="hl str"></span>
<span class="hl str">   function Fragment_Of (Element : not null Element_Access) return Compact is</span>
<span class="hl str">   begin</span>
<span class="hl str">      return Element.all.Key;</span>
<span class="hl str">   end Fragment_Of;</span>
<span class="hl str"></span>
<span class="hl str">end Statistics.Calculator;</span>
<span class="hl str"></span>
<span class="hl str">package Statistics.Aux is</span>
<span class="hl str"></span>
<span class="hl str">   pragma Elaborate_Body (Aux);</span>
<span class="hl str"></span>
<span class="hl str">   type Summary is abstract tagged limited null record;</span>
<span class="hl str">   type Report is access constant Summary'Class;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Print (Info : Summary) is abstract;</span>
<span class="hl str"></span>
<span class="hl str">   protected Printer is</span>
<span class="hl str">      procedure Log_Percent (L : Fragment_Lengths; Result : Report);</span>
<span class="hl str">      procedure Log_Count (L : Fragment_Lengths; Result : Report);</span>
<span class="hl str">   end Printer;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Print_When_Finished;</span>
<span class="hl str"></span>
<span class="hl str">   --  Tasks will start once their suspension objects become true:</span>
<span class="hl str">   procedure Unlock;</span>
<span class="hl str">   procedure Wait (Lock_Number : Fragment_Lengths);</span>
<span class="hl str"></span>
<span class="hl str">end Statistics.Aux;</span>
<span class="hl str"></span>
<span class="hl str">with Ada.Synchronous_Task_Control;    use Ada.Synchronous_Task_Control;</span>
<span class="hl str">package body Statistics.Aux is</span>
<span class="hl str"></span>
<span class="hl str">   type Task_ID is range 1 .. 7;</span>
<span class="hl str"></span>
<span class="hl str">   Lock  : array (Task_ID) of Suspension_Object;</span>
<span class="hl str">   Ready : Suspension_Object;</span>
<span class="hl str"></span>
<span class="hl str">   Percents : array (Fragment_Lengths range 1 .. 2) of Report;</span>
<span class="hl str">   Counts   : array (Fragment_Lengths range 3 .. 18) of Report;</span>
<span class="hl str"></span>
<span class="hl str">   Selection : constant array (Task_ID) of Fragment_Lengths :=</span>
<span class="hl str">     (1, 2, 3, 4, 6, 12, 18);</span>
<span class="hl str"></span>
<span class="hl str">   function All_Present return Boolean is</span>
<span class="hl str">   begin</span>
<span class="hl str">      for K in Selection'First .. Selection'First + 1 loop</span>
<span class="hl str">         if Percents (Selection (K)) = null then</span>
<span class="hl str">            return False;</span>
<span class="hl str">         end if;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">      for K in Selection'First + 2 .. Selection'Last loop</span>
<span class="hl str">         if Counts (Selection (K)) = null then</span>
<span class="hl str">            return False;</span>
<span class="hl str">         end if;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">      return True;</span>
<span class="hl str">   end All_Present;</span>
<span class="hl str"></span>
<span class="hl str">   protected body Printer is</span>
<span class="hl str"></span>
<span class="hl str">      procedure Log_Percent (L : Fragment_Lengths; Result : Report) is</span>
<span class="hl str">      begin</span>
<span class="hl str">         Percents (L) := Result;</span>
<span class="hl str">         if All_Present then</span>
<span class="hl str">            Set_True (Ready);</span>
<span class="hl str">         end if;</span>
<span class="hl str">      end Log_Percent;</span>
<span class="hl str"></span>
<span class="hl str">      procedure Log_Count (L : Fragment_Lengths; Result : Report) is</span>
<span class="hl str">      begin</span>
<span class="hl str">         Counts (L) := Result;</span>
<span class="hl str">         if All_Present then</span>
<span class="hl str">            Set_True (Ready);</span>
<span class="hl str">         end if;</span>
<span class="hl str">      end Log_Count;</span>
<span class="hl str"></span>
<span class="hl str">   end Printer;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Print_When_Finished is</span>
<span class="hl str">   begin</span>
<span class="hl str">      Suspend_Until_True (Ready);</span>
<span class="hl str">      for K in Selection'First .. Selection'First + 1 loop</span>
<span class="hl str">         Percents (Selection (K)).Print;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">      for K in Selection'First + 2 .. Selection'Last loop</span>
<span class="hl str">         Counts (Selection (K)).Print;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">   end Print_When_Finished;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Unlock is</span>
<span class="hl str">   begin</span>
<span class="hl str">      for Id in Lock'Range loop</span>
<span class="hl str">         Set_True (Lock (Id));</span>
<span class="hl str">      end loop;</span>
<span class="hl str">   end Unlock;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Wait (Lock_Number : Fragment_Lengths) is</span>
<span class="hl str">      Id_Map : constant array (Fragment_Lengths) of Task_ID :=</span>
<span class="hl str">        (1, 2, 3, 4, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7);</span>
<span class="hl str">   begin</span>
<span class="hl str">      Suspend_Until_True (Lock (Id_Map (Lock_Number)));</span>
<span class="hl str">   end Wait;</span>
<span class="hl str"></span>
<span class="hl str">end Statistics.Aux;</span>
<span class="hl str"></span>
<span class="hl str">with Data.Text_Fragments;</span>
<span class="hl str">with System;</span>
<span class="hl str">generic</span>
<span class="hl str">   with package Fragments is new Data.Text_Fragments (&lt;&gt;);</span>
<span class="hl str">package Statistics.Work is</span>
<span class="hl str"></span>
<span class="hl str">   pragma Elaborate_Body (Work);</span>
<span class="hl str"></span>
<span class="hl str">   task type Counting_Job</span>
<span class="hl str">     (Buffer : access constant Data.Compressed_View;</span>
<span class="hl str">      Length : Fragment_Lengths;</span>
<span class="hl str">      Nucleotide_Fragment : access constant Fragments.Compact)</span>
<span class="hl str">   is</span>
<span class="hl str">      pragma Storage_Size (2**18);</span>
<span class="hl str">      pragma Priority (Positive'Min</span>
<span class="hl str">                         (System.Default_Priority + Positive (Length),</span>
<span class="hl str">                          System.Max_Priority));</span>
<span class="hl str">   end Counting_Job;</span>
<span class="hl str"></span>
<span class="hl str">end Statistics.Work;</span>
<span class="hl str"></span>
<span class="hl str">with Ada.Containers.Generic_Constrained_Array_Sort;</span>
<span class="hl str">with Ada.Text_IO, Ada.Float_Text_IO, Ada.Integer_Text_IO;</span>
<span class="hl str">with Ada.Characters.Latin_1;</span>
<span class="hl str">with Statistics.Aux;</span>
<span class="hl str">with Statistics.Calculator;</span>
<span class="hl str"></span>
<span class="hl str">package body Statistics.Work is</span>
<span class="hl str"></span>
<span class="hl str">   package Stats is new Statistics.Calculator (Fragments);</span>
<span class="hl str"></span>
<span class="hl str">   type Summary_Data is array (Natural range &lt;&gt;) of Stats.Element_Access;</span>
<span class="hl str"></span>
<span class="hl str">   type Summary_Info (Num_Table_Entries : Natural;</span>
<span class="hl str">                      Sum_of_Counts     : Natural) is new Aux.Summary with</span>
<span class="hl str">      record</span>
<span class="hl str">         Data : Summary_Data (1 .. Num_Table_Entries);</span>
<span class="hl str">      end record;</span>
<span class="hl str"></span>
<span class="hl str">   overriding</span>
<span class="hl str">   procedure Print (Info : Summary_Info) is</span>
<span class="hl str">   begin</span>
<span class="hl str">      for I in 1 .. Info.Data'Last loop</span>
<span class="hl str">         Ada.Text_IO.Put</span>
<span class="hl str">           (String (Fragments.To_Fragment</span>
<span class="hl str">                      (Stats.Fragment_Of (Info.Data (I)))) &amp; '</span> <span class="hl str">');</span>
<span class="hl str">         Ada.Float_Text_IO.Put</span>
<span class="hl str">           (Item =&gt; (100.0</span>
<span class="hl str">                       * Float (Stats.Count_Of (Info.Data (I)))</span>
<span class="hl str">                       / Float (Info.Sum_of_Counts)),</span>
<span class="hl str">            Fore =&gt; 1,</span>
<span class="hl str">            Aft  =&gt; 3,</span>
<span class="hl str">            Exp  =&gt; 0);</span>
<span class="hl str">         Ada.Text_IO.New_Line;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">      Ada.Text_IO.New_Line;</span>
<span class="hl str">   end Print;</span>
<span class="hl str"></span>
<span class="hl str">   type Fragment_Info is new Aux.Summary with</span>
<span class="hl str">      record</span>
<span class="hl str">         Counted : Natural;</span>
<span class="hl str">         Nucleotide_Fragment : Fragments.Fragment;</span>
<span class="hl str">      end record;</span>
<span class="hl str"></span>
<span class="hl str">   overriding</span>
<span class="hl str">   procedure Print (Info : Fragment_Info) is</span>
<span class="hl str">   begin</span>
<span class="hl str">      Ada.Integer_Text_IO.Put</span>
<span class="hl str">        (Item =&gt; Info.Counted,</span>
<span class="hl str">         Width =&gt; 1);</span>
<span class="hl str">      Ada.Text_IO.Put (Ada.Characters.Latin_1.HT);</span>
<span class="hl str">      Ada.Text_IO.Put_Line (String (Info.Nucleotide_Fragment));</span>
<span class="hl str">   end Print;</span>
<span class="hl str"></span>
<span class="hl str">   Num_Table_Entries : Natural;</span>
<span class="hl str">   Sum_of_Counts     : Natural;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Perform_Counting (Buffer : Data.Compressed) is</span>
<span class="hl str">   begin</span>
<span class="hl str">      if Fragments.Compact'Length &gt;= 12 then</span>
<span class="hl str">         Stats.Get_Frequencies_Big (Buffer);</span>
<span class="hl str">      else</span>
<span class="hl str">         Stats.Get_Frequencies_Small (Buffer);</span>
<span class="hl str">         if Fragments.Compact'Length &lt;= 2 then</span>
<span class="hl str">            Stats.Get_Totals</span>
<span class="hl str">              (Total =&gt; Sum_of_Counts,</span>
<span class="hl str">               Count =&gt; Num_Table_Entries);</span>
<span class="hl str">         end if;</span>
<span class="hl str">      end if;</span>
<span class="hl str">   end Perform_Counting;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Write_Percent (Nucleotide_Length : Fragment_Lengths) is</span>
<span class="hl str">      use Fragments;</span>
<span class="hl str">      subtype Index is Natural range 1 .. Num_Table_Entries;</span>
<span class="hl str">      subtype List_of_Results is Summary_Data (Index);</span>
<span class="hl str"></span>
<span class="hl str">      Sheet : List_of_Results;</span>
<span class="hl str"></span>
<span class="hl str">      function Less_Than (Left, Right : Stats.Element_Access) return Boolean is</span>
<span class="hl str">      begin</span>
<span class="hl str">         return Stats.Count_Of (Left) &gt; Stats.Count_Of (Right);</span>
<span class="hl str">      end Less_Than;</span>
<span class="hl str"></span>
<span class="hl str">      procedure Sort is new Ada.Containers.Generic_Constrained_Array_Sort</span>
<span class="hl str">        (Index_Type   =&gt; Index,</span>
<span class="hl str">         Element_Type =&gt; Stats.Element_Access,</span>
<span class="hl str">         Array_Type   =&gt; List_of_Results,</span>
<span class="hl str">         &quot;&lt;&quot;          =&gt; Less_Than);</span>
<span class="hl str"></span>
<span class="hl str">   begin</span>
<span class="hl str">      Sheet (1) := Stats.Get_First;</span>
<span class="hl str">      for I in 2 .. Sheet'Last loop</span>
<span class="hl str">         Sheet (I) := Stats.Get_Next;</span>
<span class="hl str">      end loop;</span>
<span class="hl str"></span>
<span class="hl str">      Sort (Sheet);</span>
<span class="hl str"></span>
<span class="hl str">      Aux.Printer.Log_Percent</span>
<span class="hl str">        (Nucleotide_Length,</span>
<span class="hl str">         new Summary_Info'</span><span class="hl opt">(</span>Num_Table_Entries<span class="hl opt">,</span>
                           Sum_of_Counts<span class="hl opt">,</span>
                           Sheet<span class="hl opt">));</span>
   <span class="hl kwa">end</span> Write_Percent<span class="hl opt">;</span>

   <span class="hl kwa">procedure</span> Write_Count <span class="hl opt">(</span>Nucleotide_Fragment <span class="hl opt">:</span> Fragments<span class="hl opt">.</span>Compact<span class="hl opt">)</span> <span class="hl kwa">is</span>
      No_of_Occurrences <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">Natural</span> <span class="hl opt">:=</span>
        Stats<span class="hl opt">.</span>Occurrences <span class="hl opt">(</span>Nucleotide_Fragment<span class="hl opt">);</span>
   <span class="hl kwa">begin</span>
      Aux<span class="hl opt">.</span>Printer<span class="hl opt">.</span>Log_Count
        <span class="hl opt">(</span>Nucleotide_Fragment<span class="hl kwd">'Length</span><span class="hl opt">,</span>
         <span class="hl kwa">new</span> Fragment_Info<span class="hl str">'(No_of_Occurrences,</span>
<span class="hl str">                            Fragments.To_Fragment (Nucleotide_Fragment)));</span>
<span class="hl str">   end Write_Count;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">   task body Counting_Job is</span>
<span class="hl str">   begin</span>
<span class="hl str">      Aux.Wait (Lock_Number =&gt; Length);</span>
<span class="hl str"></span>
<span class="hl str">      Perform_Counting (Buffer.all.all);</span>
<span class="hl str"></span>
<span class="hl str">      case Length is</span>
<span class="hl str">         when 1 | 2 =&gt;</span>
<span class="hl str">            Write_Percent (Length);</span>
<span class="hl str"></span>
<span class="hl str">         when 3 | 4 | 6 | 12 | 18 =&gt;</span>
<span class="hl str">            Write_Count (Nucleotide_Fragment.all);</span>
<span class="hl str"></span>
<span class="hl str">         when others =&gt;</span>
<span class="hl str">            raise Program_Error;</span>
<span class="hl str">      end case;</span>
<span class="hl str"></span>
<span class="hl str">   end Counting_Job;</span>
<span class="hl str"></span>
<span class="hl str">end Statistics.Work;</span>
<span class="hl str"></span>
<span class="hl str">with Ada.Unchecked_Deallocation;</span>
<span class="hl str">package Data_Input is</span>
<span class="hl str"></span>
<span class="hl str">   --  Read data from Standard_Input and return section THREE as String:</span>
<span class="hl str"></span>
<span class="hl str">   function Read return String;</span>
<span class="hl str"></span>
<span class="hl str">   type Writable_String_Access is access all String;</span>
<span class="hl str">   procedure Free is new Ada.Unchecked_Deallocation</span>
<span class="hl str">     (String, Writable_String_Access);</span>
<span class="hl str"></span>
<span class="hl str">end Data_Input;</span>
<span class="hl str"></span>
<span class="hl str">with Ada.IO_Exceptions;</span>
<span class="hl str">with Ada.Strings.Unbounded;</span>
<span class="hl str">with Line_IO;</span>
<span class="hl str"></span>
<span class="hl str">package body Data_Input is</span>
<span class="hl str"></span>
<span class="hl str">   use Ada.Strings;</span>
<span class="hl str"></span>
<span class="hl str">   Data_Buffer : Unbounded.Unbounded_String := Unbounded.Null_Unbounded_String;</span>
<span class="hl str"></span>
<span class="hl str">   Section_Marker : constant Character := '</span><span class="hl opt">&gt;</span><span class="hl str">';</span>
<span class="hl str">   Section        : constant String    := Section_Marker &amp; &quot;THREE&quot;;</span>
<span class="hl str"></span>
<span class="hl str">   --  Read next data section until EOF oder a line beginning with &gt; is found.</span>
<span class="hl str"></span>
<span class="hl str">   procedure Read_Section is</span>
<span class="hl str">      Buffer     : Writable_String_Access;</span>
<span class="hl str">      Read_First : Natural;</span>
<span class="hl str">      Read_Last  : Natural;</span>
<span class="hl str">   begin</span>
<span class="hl str">      Buffer := new String (1 .. 1024 * 1024 * 16);</span>
<span class="hl str">      Get_Data : loop</span>
<span class="hl str">         Read_First := Buffer'First;</span>
<span class="hl str">         Read_Last  := Buffer'First - 1;</span>
<span class="hl str">         --  fill Buffer and append to Data_Buffer when filled</span>
<span class="hl str">         loop</span>
<span class="hl str">            declare</span>
<span class="hl str">               Line : String renames Line_IO.Get_Line;</span>
<span class="hl str">            begin</span>
<span class="hl str">               Read_Last := Read_First + Line'Length - 1;</span>
<span class="hl str">               if Read_Last &gt;= Buffer'Last then</span>
<span class="hl str">                  Unbounded.Append</span>
<span class="hl str">                    (Data_Buffer, New_Item =&gt; Buffer (1 .. Read_First - 1));</span>
<span class="hl str">                  Unbounded.Append (Data_Buffer, New_Item =&gt; Line);</span>
<span class="hl str">                  exit;</span>
<span class="hl str">               end if;</span>
<span class="hl str">               Buffer (Read_First .. Read_Last) := Line;</span>
<span class="hl str">            end;</span>
<span class="hl str">            exit Get_Data when Buffer (Read_First) = Section_Marker;</span>
<span class="hl str">            Read_First := Read_Last + 1;</span>
<span class="hl str">         end loop;</span>
<span class="hl str">      end loop Get_Data;</span>
<span class="hl str">      Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));</span>
<span class="hl str">      Free (Buffer);</span>
<span class="hl str">   exception</span>
<span class="hl str">      when Ada.IO_Exceptions.End_Error =&gt;</span>
<span class="hl str">         Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));</span>
<span class="hl str">         Free (Buffer);</span>
<span class="hl str">   end Read_Section;</span>
<span class="hl str"></span>
<span class="hl str">   --  Skip data on Standard_Input until &quot;&gt;THREE&quot; is found</span>
<span class="hl str"></span>
<span class="hl str">   procedure Skip_To_Section is</span>
<span class="hl str">   begin</span>
<span class="hl str">      loop</span>
<span class="hl str">         declare</span>
<span class="hl str">            Line : constant String := Line_IO.Get_Line;</span>
<span class="hl str">         begin</span>
<span class="hl str">            exit when Line (1) = Section (1)</span>
<span class="hl str">              and then Line (Section'Range) = Section;</span>
<span class="hl str">         end;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">   end Skip_To_Section;</span>
<span class="hl str"></span>
<span class="hl str">   function Read return String is</span>
<span class="hl str">   begin</span>
<span class="hl str">      Skip_To_Section;</span>
<span class="hl str">      Read_Section;</span>
<span class="hl str">      return Unbounded.To_String (Data_Buffer);</span>
<span class="hl str">   end Read;</span>
<span class="hl str"></span>
<span class="hl str">end Data_Input;</span>
<span class="hl str"></span>
<span class="hl str">package Line_IO is</span>
<span class="hl str"></span>
<span class="hl str">   pragma Elaborate_Body (Line_IO);</span>
<span class="hl str"></span>
<span class="hl str">   Separator : constant String := (1 =&gt; ASCII.LF);  --  ends a line</span>
<span class="hl str"></span>
<span class="hl str">   function Get_Line return String;</span>
<span class="hl str"></span>
<span class="hl str">end Line_IO;</span>
<span class="hl str"></span>
<span class="hl str">with Ada.Streams.Stream_IO;</span>
<span class="hl str">package body Line_IO is</span>
<span class="hl str"></span>
<span class="hl str">   use Ada.Streams;</span>
<span class="hl str"></span>
<span class="hl str">   Stdin : Stream_IO.File_Type;</span>
<span class="hl str"></span>
<span class="hl str">   --  Declarations associated with filling a text buffer.</span>
<span class="hl str"></span>
<span class="hl str">   BUFSIZ : constant := 8_192 * 2;</span>
<span class="hl str">   pragma Assert (Character'Size = Stream_Element'Size);</span>
<span class="hl str"></span>
<span class="hl str">   SL : constant Natural := Separator'Length;</span>
<span class="hl str"></span>
<span class="hl str">   subtype Extended_Buffer_Index is Positive range 1 .. BUFSIZ + SL;</span>
<span class="hl str">   subtype Buffer_Index is Extended_Buffer_Index</span>
<span class="hl str">     range Extended_Buffer_Index'First .. Extended_Buffer_Index'Last - SL;</span>
<span class="hl str">   subtype Extended_Bytes_Index is Stream_Element_Offset</span>
<span class="hl str">     range 1 .. Stream_Element_Offset (Extended_Buffer_Index'Last);</span>
<span class="hl str">   subtype Bytes_Index is Extended_Bytes_Index</span>
<span class="hl str">     range Extended_Bytes_Index'First</span>
<span class="hl str">     .. (Extended_Bytes_Index'Last - Stream_Element_Offset (SL));</span>
<span class="hl str"></span>
<span class="hl str">   subtype Buffer_Data is String (Extended_Buffer_Index);</span>
<span class="hl str">   subtype Buffer_Bytes is Stream_Element_Array (Extended_Bytes_Index);</span>
<span class="hl str"></span>
<span class="hl str">   Buffer : Buffer_Data;</span>
<span class="hl str">   Bytes  : Buffer_Bytes;</span>
<span class="hl str">   for Bytes'Address use Buffer'Address;</span>
<span class="hl str">   pragma Import (Ada, Bytes);</span>
<span class="hl str"></span>
<span class="hl str">   --  start of next substring and last valid character in buffer</span>
<span class="hl str">   Position : Natural range 0 .. Extended_Buffer_Index'Last;</span>
<span class="hl str">   Last     : Natural range 0 .. Buffer_Index'Last;</span>
<span class="hl str">   End_of_Input : Boolean;</span>
<span class="hl str"></span>
<span class="hl str">   function Get_Line return String is</span>
<span class="hl str"></span>
<span class="hl str">      procedure Reload is</span>
<span class="hl str">         --  fill Buffer with bytes available</span>
<span class="hl str">         Last_Filled : Stream_Element_Offset;</span>
<span class="hl str">      begin</span>
<span class="hl str">         if Last &lt; Buffer_Index'Last then</span>
<span class="hl str">            raise Stream_IO.End_Error;</span>
<span class="hl str">         end if;</span>
<span class="hl str">         Stream_IO.Read (Stdin,</span>
<span class="hl str">           Item =&gt; Bytes (Bytes_Index),</span>
<span class="hl str">           Last =&gt; Last_Filled);</span>
<span class="hl str">         Last := Natural (Last_Filled);</span>
<span class="hl str">         Position := 1;</span>
<span class="hl str">         Buffer (Last + 1 .. Last + SL) := Separator;</span>
<span class="hl str">      end Reload;</span>
<span class="hl str"></span>
<span class="hl str">      function Separator_Position return Natural is</span>
<span class="hl str">         --   index of next Separator (may be sentinel)</span>
<span class="hl str">         K : Extended_Buffer_Index := Position;</span>
<span class="hl str">      begin</span>
<span class="hl str">         loop</span>
<span class="hl str">            if Buffer (K) = Separator (1) then</span>
<span class="hl str">               exit;</span>
<span class="hl str">            elsif Buffer (K+1) = Separator (1) then</span>
<span class="hl str">               K := K + 1; exit;</span>
<span class="hl str">            else</span>
<span class="hl str">               K := K + 2;</span>
<span class="hl str">            end if;</span>
<span class="hl str">         end loop;</span>
<span class="hl str">         return K;</span>
<span class="hl str">      end Separator_Position;</span>
<span class="hl str"></span>
<span class="hl str">      Next_Separator : Natural range 0 .. Extended_Buffer_Index'Last;</span>
<span class="hl str">   begin  --  Get_Line</span>
<span class="hl str"></span>
<span class="hl str">      if End_of_Input then</span>
<span class="hl str">         raise Stream_IO.End_Error;</span>
<span class="hl str">      end if;</span>
<span class="hl str"></span>
<span class="hl str">      Next_Separator := Separator_Position;</span>
<span class="hl str"></span>
<span class="hl str">      if Next_Separator &gt; Last then</span>
<span class="hl str">         declare</span>
<span class="hl str">            Result : constant String := Buffer (Position .. Last);</span>
<span class="hl str">            subtype XString is String (1 .. Last - Position + 1);</span>
<span class="hl str">         begin</span>
<span class="hl str">            begin</span>
<span class="hl str">               Reload;</span>
<span class="hl str">               return XString (Result) &amp; Get_Line;</span>
<span class="hl str">            exception</span>
<span class="hl str">               when Stream_IO.End_Error =&gt;</span>
<span class="hl str">                  End_of_Input := True;</span>
<span class="hl str">                  return XString (Result);</span>
<span class="hl str">            end;</span>
<span class="hl str">         end;</span>
<span class="hl str">      else</span>
<span class="hl str">         declare</span>
<span class="hl str">            Result : String renames Buffer (Position .. Next_Separator - 1);</span>
<span class="hl str">            subtype XString is String (1 .. Next_Separator - Position);</span>
<span class="hl str">         begin</span>
<span class="hl str">            Position := Next_Separator + SL;</span>
<span class="hl str">            return XString (Result);</span>
<span class="hl str">         end;</span>
<span class="hl str">      end if;</span>
<span class="hl str"></span>
<span class="hl str">   end Get_Line;</span>
<span class="hl str"></span>
<span class="hl str">begin</span>
<span class="hl str">   Stream_IO.Open (Stdin,</span>
<span class="hl str">     Mode =&gt; Stream_IO.In_File,</span>
<span class="hl str">     Name =&gt; &quot;/dev/stdin&quot;);</span>
<span class="hl str"></span>
<span class="hl str">   Buffer (Buffer_Index'Last + 1 .. Buffer'Last) := Separator;</span>
<span class="hl str">   Position := Buffer_Index'Last + 1;</span>
<span class="hl str">   Last := Buffer_Index'Last;</span>
<span class="hl str">   End_of_Input := False;</span>
<span class="hl str">end Line_IO;</span>
