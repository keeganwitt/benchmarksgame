<span class="hl slc">;;   The Computer Language Benchmarks Game</span>
<span class="hl slc">;;   http://benchmarksgame.alioth.debian.org/</span>

<span class="hl slc">;; contributed by Andy Fingerhut</span>
<span class="hl slc">;; modified by Marko Kocic</span>
<span class="hl slc">;; modified by Mike Anderson to make better use of primitive operations</span>
<span class="hl slc">;; modified by Andy Fingerhut for lower CPU use and high parallelism</span>

<span class="hl slc">;; Ideas for future enhancement: Better parallelism: Do completion of</span>
<span class="hl slc">;; DNA string reading while beginning hash table creation in parallel.</span>
<span class="hl slc">;; Lower memory use: Read DNA string as bytes instead of Java chars.</span>

<span class="hl opt">(</span><span class="hl kwa">ns</span> knucleotide
  <span class="hl opt">(:</span>import java.util.concurrent.ExecutorService
           java.util.concurrent.Executors<span class="hl opt">)</span>
  <span class="hl opt">(:</span>gen-class<span class="hl opt">))</span>

<span class="hl opt">(</span><span class="hl kwa">set</span><span class="hl opt">! *</span>warn-on-reflection<span class="hl opt">*</span> true<span class="hl opt">)</span>


<span class="hl slc">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="hl slc">;; This is a copy of part of Amit Rathore's Medusa package, which</span>
<span class="hl slc">;; allows you to submit a bunch of Clojure expressions to run to a</span>
<span class="hl slc">;; thread pool with a fixed size.  No more than that many threads will</span>
<span class="hl slc">;; ever run at once, but Medusa tries to keep that many threads going</span>
<span class="hl slc">;; at all times, as long as there are things to do that have been</span>
<span class="hl slc">;; submitted.  This is unlike Clojure's built-in pmap, which often</span>
<span class="hl slc">;; runs fewer threads in parallel if the run time of the jobs differs</span>
<span class="hl slc">;; significantly from each other.</span>
<span class="hl slc">;;</span>
<span class="hl slc">;; git clone http://github.com/amitrathore/clj-utils.git</span>
<span class="hl slc">;; git clone http://github.com/amitrathore/medusa.git</span>
<span class="hl slc">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="hl opt">(</span><span class="hl kwa">def</span> THREADPOOL<span class="hl opt">)</span>

<span class="hl opt">(</span><span class="hl kwa">def</span> running-futures <span class="hl opt">(</span><span class="hl kwa">ref</span> <span class="hl opt">{}))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> create-runonce <span class="hl opt">[</span>function<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>sentinel <span class="hl opt">(</span><span class="hl kwa">Object</span>.<span class="hl opt">)</span>
        result <span class="hl opt">(</span><span class="hl kwa">atom</span> sentinel<span class="hl opt">)]</span> 
    <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[&amp;</span> args<span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">locking</span> sentinel 
        <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(= &#64;</span>result sentinel<span class="hl opt">)</span>
          <span class="hl opt">(</span><span class="hl kwa">reset</span><span class="hl opt">!</span> result <span class="hl opt">(</span><span class="hl kwa">apply</span> function args<span class="hl opt">))</span> 
          <span class="hl opt">&#64;</span>result<span class="hl opt">)))))</span>

<span class="hl opt">(</span><span class="hl kwa">defmacro</span> defrunonce <span class="hl opt">[</span>fn-name args <span class="hl opt">&amp;</span> body<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">def</span> ~fn-name <span class="hl opt">(</span><span class="hl kwa">create-runonce</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> ~args ~<span class="hl opt">&#64;</span>body<span class="hl opt">))))</span>

<span class="hl opt">(</span><span class="hl kwa">defrunonce</span> init-medusa <span class="hl opt">[</span>pool-size<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">def</span> THREADPOOL <span class="hl opt">(</span><span class="hl kwa">Executors</span><span class="hl opt">/</span>newFixedThreadPool pool-size<span class="hl opt">)))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> claim-thread <span class="hl opt">[</span>future-id<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>thread-info <span class="hl opt">{:</span>thread <span class="hl opt">(</span><span class="hl kwa">Thread</span><span class="hl opt">/</span>currentThread<span class="hl opt">) :</span>future-id future-id
                     <span class="hl opt">:</span>started <span class="hl opt">(</span><span class="hl kwa">System</span><span class="hl opt">/</span>currentTimeMillis<span class="hl opt">)}]</span>
    <span class="hl opt">(</span><span class="hl kwa">dosync</span> <span class="hl opt">(</span><span class="hl kwa">alter</span> running-futures assoc future-id thread-info<span class="hl opt">))))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> mark-completion <span class="hl opt">[</span>future-id<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">dosync</span> <span class="hl opt">(</span><span class="hl kwa">alter</span> running-futures dissoc future-id<span class="hl opt">)))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> medusa-future-thunk <span class="hl opt">[</span>future-id thunk<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^Callable work <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[]</span>
                         <span class="hl opt">(</span><span class="hl kwa">claim-thread</span> future-id<span class="hl opt">)</span>
                         <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>val <span class="hl opt">(</span><span class="hl kwa">thunk</span><span class="hl opt">)]</span>
                           <span class="hl opt">(</span><span class="hl kwa">mark-completion</span> future-id<span class="hl opt">)</span>
                           val<span class="hl opt">))]</span>
    <span class="hl opt">(</span>.submit ^ExecutorService THREADPOOL work<span class="hl opt">)))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> random-uuid <span class="hl opt">[]</span>
  <span class="hl opt">(</span><span class="hl kwa">str</span> <span class="hl opt">(</span><span class="hl kwa">java</span>.util.UUID<span class="hl opt">/</span>randomUUID<span class="hl opt">)))</span>

<span class="hl opt">(</span><span class="hl kwa">defmacro</span> medusa-future <span class="hl opt">[&amp;</span> body<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">medusa-future-thunk</span> <span class="hl opt">(</span><span class="hl kwa">random-uuid</span><span class="hl opt">) (</span><span class="hl kwa">fn</span> <span class="hl opt">[] (</span><span class="hl kwa">do</span> ~<span class="hl opt">&#64;</span>body<span class="hl opt">))))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> medusa-pmap <span class="hl opt">[</span>num-threads f coll<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(==</span> num-threads <span class="hl num">1</span><span class="hl opt">)</span>
    <span class="hl opt">(</span><span class="hl kwa">map</span> f coll<span class="hl opt">)</span>
    <span class="hl opt">(</span><span class="hl kwa">do</span>
      <span class="hl opt">(</span><span class="hl kwa">init-medusa</span> num-threads<span class="hl opt">)</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>seq-of-futures <span class="hl opt">(</span><span class="hl kwa">doall</span> <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">#(</span><span class="hl kwa">medusa-future</span> <span class="hl opt">(</span><span class="hl kwa">f</span> %<span class="hl opt">))</span> coll<span class="hl opt">))]</span>
        <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>java-future<span class="hl opt">] (</span>.get ^java.util.concurrent.Future java-future<span class="hl opt">))</span>
             seq-of-futures<span class="hl opt">)))))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> shutdown-medusa <span class="hl opt">[]</span>
  <span class="hl opt">(</span>.shutdown ^ExecutorService THREADPOOL<span class="hl opt">))</span>

<span class="hl slc">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="hl slc">;; This is the end of the subset of Medusa code.</span>
<span class="hl slc">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>


<span class="hl opt">(</span><span class="hl kwa">defmacro</span> key-type <span class="hl opt">[</span>num<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">long</span> ~num<span class="hl opt">))</span>

<span class="hl opt">(</span><span class="hl kwa">definterface</span> IFragment
  <span class="hl opt">(</span><span class="hl kwa">set_key_BANG_</span> <span class="hl opt">[</span>^long k<span class="hl opt">])</span>
  <span class="hl opt">(</span>^long get_key <span class="hl opt">[])</span>
  <span class="hl opt">(</span><span class="hl kwa">inc_BANG_</span> <span class="hl opt">[])</span>
  <span class="hl opt">(</span><span class="hl kwa">add_BANG_</span> <span class="hl opt">[</span>^int n<span class="hl opt">])</span>
  <span class="hl opt">(</span>^int get_count <span class="hl opt">[]))</span>


<span class="hl opt">(</span><span class="hl kwa">deftype</span> Fragment <span class="hl opt">[</span>^<span class="hl opt">{:</span>unsynchronized-mutable true <span class="hl opt">:</span>tag long<span class="hl opt">}</span> key
                       ^<span class="hl opt">{:</span>unsynchronized-mutable true <span class="hl opt">:</span>tag int<span class="hl opt">}</span> cnt<span class="hl opt">]</span>
  Object
  <span class="hl slc">;; TBD: Is there a way to return an int hashCode that is a truncated</span>
  <span class="hl slc">;; version of the long value key without using bit-and?  Simply</span>
  <span class="hl slc">;; using (int key) throws an exception if key is larger than</span>
  <span class="hl slc">;; Integer/MAX_VALUE, e.g. (int Long/MAX_VALUE).</span>
  <span class="hl opt">(</span>^int hashCode <span class="hl opt">[</span>this<span class="hl opt">]</span>
    <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> key Integer<span class="hl opt">/</span>MAX_VALUE<span class="hl opt">)))</span>
  <span class="hl opt">(</span>^boolean equals <span class="hl opt">[</span>this ^Object o<span class="hl opt">]</span>
    <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^Fragment f o<span class="hl opt">]</span>
      <span class="hl opt">(==</span> key <span class="hl opt">(</span>.key f<span class="hl opt">))))</span>

  IFragment
  <span class="hl opt">(</span><span class="hl kwa">set-key</span><span class="hl opt">! [</span>this ^long k<span class="hl opt">]</span>
    <span class="hl opt">(</span><span class="hl kwa">set</span><span class="hl opt">!</span> key k<span class="hl opt">))</span>
  <span class="hl opt">(</span><span class="hl kwa">get-key</span> <span class="hl opt">[</span>this<span class="hl opt">]</span> key<span class="hl opt">)</span>
  <span class="hl opt">(</span><span class="hl kwa">inc</span><span class="hl opt">! [</span>this<span class="hl opt">]</span>
    <span class="hl opt">(</span><span class="hl kwa">set</span><span class="hl opt">!</span> cnt <span class="hl opt">(</span><span class="hl kwa">unchecked-inc-int</span> cnt<span class="hl opt">)))</span>
  <span class="hl opt">(</span><span class="hl kwa">add</span><span class="hl opt">! [</span>this ^int n<span class="hl opt">]</span>
    <span class="hl opt">(</span><span class="hl kwa">set</span><span class="hl opt">!</span> cnt <span class="hl opt">(</span><span class="hl kwa">unchecked-add-int</span> cnt n<span class="hl opt">)))</span>
  <span class="hl opt">(</span><span class="hl kwa">get-count</span> <span class="hl opt">[</span>this<span class="hl opt">]</span> cnt<span class="hl opt">))</span>

 

<span class="hl slc">;; Return true when the line l is a FASTA description line</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> fasta-description-line <span class="hl opt">[</span>l<span class="hl opt">]</span>
  <span class="hl opt">(=</span> \<span class="hl opt">&gt; (</span><span class="hl kwa">first</span> <span class="hl opt">(</span><span class="hl kwa">seq</span> l<span class="hl opt">))))</span>


<span class="hl slc">;; Return true when the line l is a FASTA description line that begins</span>
<span class="hl slc">;; with the string desc-str.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> fasta-description-line-beginning <span class="hl opt">[</span>desc-str l<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">and</span> <span class="hl opt">(</span><span class="hl kwa">fasta-description-line</span> l<span class="hl opt">)</span>
       <span class="hl opt">(=</span> desc-str <span class="hl opt">(</span><span class="hl kwa">subs</span> l <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">min</span> <span class="hl opt">(</span><span class="hl kwa">count</span> l<span class="hl opt">) (</span><span class="hl kwa">inc</span> <span class="hl opt">(</span><span class="hl kwa">count</span> desc-str<span class="hl opt">)))))))</span>


<span class="hl slc">;; Take a sequence of lines from a FASTA format file, and a string</span>
<span class="hl slc">;; desc-str.  Look for a FASTA record with a description that begins</span>
<span class="hl slc">;; with desc-str, and if one is found, return its DNA sequence as a</span>
<span class="hl slc">;; single (potentially quite long) string.  If input file is big,</span>
<span class="hl slc">;; you'll save lots of memory if you call this function in a with-open</span>
<span class="hl slc">;; for the file, and don't hold on to the head of the lines parameter.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> fasta-dna-str-with-desc-beginning <span class="hl opt">[</span>desc-str lines<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">when-let</span> <span class="hl opt">[</span>x <span class="hl opt">(</span><span class="hl kwa">drop-while</span>
		<span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>l<span class="hl opt">] (</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">fasta-description-line-beginning</span> desc-str l<span class="hl opt">)))</span>
		lines<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">when-let</span> <span class="hl opt">[</span>x <span class="hl opt">(</span><span class="hl kwa">seq</span> x<span class="hl opt">)]</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>y <span class="hl opt">(</span><span class="hl kwa">take-while</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>l<span class="hl opt">] (</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">fasta-description-line</span> l<span class="hl opt">)))</span>
                          <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[#</span>^java.lang.String s<span class="hl opt">] (</span>.toUpperCase s<span class="hl opt">))</span>
                               <span class="hl opt">(</span><span class="hl kwa">rest</span> x<span class="hl opt">)))]</span>
        <span class="hl opt">(</span><span class="hl kwa">apply</span> str y<span class="hl opt">)))))</span>


<span class="hl opt">(</span><span class="hl kwa">def</span> dna-char-to-code-val-map <span class="hl opt">{</span>\A <span class="hl num">0</span><span class="hl opt">,</span> \C <span class="hl num">1</span><span class="hl opt">,</span> \T <span class="hl num">2</span><span class="hl opt">,</span> \G <span class="hl num">3</span><span class="hl opt">})</span>
<span class="hl opt">(</span><span class="hl kwa">def</span> code-val-to-dna-char <span class="hl opt">{</span><span class="hl num">0</span> \A<span class="hl opt">,</span> <span class="hl num">1</span> \C<span class="hl opt">,</span> <span class="hl num">2</span> \T<span class="hl opt">,</span> <span class="hl num">3</span> \G<span class="hl opt">})</span>

<span class="hl opt">(</span><span class="hl kwa">defmacro</span> dna-char-to-code-val <span class="hl opt">[</span>ch<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">case</span> ~ch
     ~<span class="hl opt">&#64;(</span><span class="hl kwa">flatten</span> <span class="hl opt">(</span><span class="hl kwa">seq</span> dna-char-to-code-val-map<span class="hl opt">))))</span>

<span class="hl slc">;; In the hash map 'tally' in tally-dna-subs-with-len, it is more</span>
<span class="hl slc">;; straightforward to use a Clojure string (same as a Java string) as</span>
<span class="hl slc">;; the key, but such a key is significantly bigger than it needs to</span>
<span class="hl slc">;; be, increasing memory and time required to hash the value.  By</span>
<span class="hl slc">;; converting a string of A, C, T, and G characters down to an integer</span>
<span class="hl slc">;; that contains only 2 bits for each character, we make a value that</span>
<span class="hl slc">;; is significantly smaller and faster to use as a key in the map.</span>

<span class="hl slc">;;    most                 least</span>
<span class="hl slc">;; significant          significant</span>
<span class="hl slc">;; bits of int          bits of int</span>
<span class="hl slc">;;  |                         |</span>
<span class="hl slc">;;  V                         V</span>
<span class="hl slc">;; code code code ....  code code</span>
<span class="hl slc">;;  ^                         ^</span>
<span class="hl slc">;;  |                         |</span>
<span class="hl slc">;; code for               code for</span>
<span class="hl slc">;; *latest*               *earliest*</span>
<span class="hl slc">;; char in                char in</span>
<span class="hl slc">;; sequence               sequence</span>

<span class="hl slc">;; Note: Given Clojure 1.2's implementation of bit-shift-left/right</span>
<span class="hl slc">;; operations, when the value being shifted is larger than a 32-bit</span>
<span class="hl slc">;; int, they are faster when the shift amount is a compile time</span>
<span class="hl slc">;; constant.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> ^<span class="hl opt">:</span>static dna-str-to-key 
  <span class="hl opt">(</span>^long <span class="hl opt">[</span>^String s<span class="hl opt">] (</span><span class="hl kwa">dna-str-to-key</span> s <span class="hl num">0</span> <span class="hl opt">(</span><span class="hl kwa">count</span> s<span class="hl opt">)))</span>
  <span class="hl opt">(</span>^long <span class="hl opt">[</span>^String s ^long start ^long length<span class="hl opt">]</span>
    <span class="hl slc">;; Accessing a local let binding is much faster than accessing a var</span>
    <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>key <span class="hl opt">(</span><span class="hl kwa">long</span> <span class="hl num">0</span><span class="hl opt">)</span>
           offset <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(+</span> start length -<span class="hl num">1</span><span class="hl opt">))]</span>
      <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;</span> offset start<span class="hl opt">)</span>
        key
        <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>c <span class="hl opt">(</span>.charAt s offset<span class="hl opt">)</span>
              code <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">dna-char-to-code-val</span> c<span class="hl opt">))</span>
              new-key <span class="hl opt">(+ (</span><span class="hl kwa">bit-shift-left</span> key <span class="hl num">2</span><span class="hl opt">)</span> code<span class="hl opt">)]</span>
          <span class="hl opt">(</span><span class="hl kwa">recur</span> new-key <span class="hl opt">(</span><span class="hl kwa">dec</span> offset<span class="hl opt">)))))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> key-to-dna-str <span class="hl opt">[</span>^Fragment f len<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>k <span class="hl opt">(</span>.get-key f<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">apply</span> str <span class="hl opt">(</span><span class="hl kwa">map</span> code-val-to-dna-char
                    <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>pos<span class="hl opt">] (</span><span class="hl kwa">bit-and</span> <span class="hl num">3</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> k pos<span class="hl opt">)))</span>
                         <span class="hl opt">(</span><span class="hl kwa">range</span> <span class="hl num">0</span> <span class="hl opt">(*</span> <span class="hl num">2</span> len<span class="hl opt">)</span> <span class="hl num">2</span><span class="hl opt">))))))</span>

<span class="hl slc">;; required function : &quot;to update a hashtable of k-nucleotide keys and</span>
<span class="hl slc">;; count values, for a particular reading-frame&quot;</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> tally-dna-subs-with-len <span class="hl opt">[</span>len dna-str start-offset end-offset<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>len <span class="hl opt">(</span><span class="hl kwa">int</span> len<span class="hl opt">)</span>
        start-offset <span class="hl opt">(</span><span class="hl kwa">int</span> start-offset<span class="hl opt">)</span>
        dna-str ^String dna-str
        mask-width <span class="hl opt">(*</span> <span class="hl num">2</span> len<span class="hl opt">)</span>
        mask <span class="hl opt">(</span><span class="hl kwa">key-type</span> <span class="hl opt">(</span><span class="hl kwa">dec</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1</span> mask-width<span class="hl opt">)))]</span>
    <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>offset <span class="hl opt">(</span><span class="hl kwa">int</span> end-offset<span class="hl opt">)</span>
           key <span class="hl opt">(</span><span class="hl kwa">key-type</span> <span class="hl opt">(</span><span class="hl kwa">dna-str-to-key</span> dna-str offset len<span class="hl opt">))</span>
           tally <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>h <span class="hl opt">(</span><span class="hl kwa">java</span>.util.HashMap.<span class="hl opt">)</span>
                       one <span class="hl opt">(</span><span class="hl kwa">Fragment</span>. <span class="hl opt">(</span><span class="hl kwa">long</span> key<span class="hl opt">) (</span><span class="hl kwa">int</span> <span class="hl num">1</span><span class="hl opt">))]</span>
                   <span class="hl opt">(</span>.put h one one<span class="hl opt">)</span>
                   h<span class="hl opt">)</span>
           fragment <span class="hl opt">(</span><span class="hl kwa">Fragment</span>. <span class="hl opt">(</span><span class="hl kwa">long</span> <span class="hl num">0</span><span class="hl opt">) (</span><span class="hl kwa">int</span> <span class="hl num">1</span><span class="hl opt">))]</span>
      <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;=</span> offset start-offset<span class="hl opt">)</span>
        tally
        <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>new-offset <span class="hl opt">(</span><span class="hl kwa">unchecked-dec</span> offset<span class="hl opt">)</span>
              new-first-char-code <span class="hl opt">(</span><span class="hl kwa">dna-char-to-code-val</span>
                                   <span class="hl opt">(</span>.charAt dna-str new-offset<span class="hl opt">))</span>
              new-key <span class="hl opt">(</span><span class="hl kwa">key-type</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> mask <span class="hl opt">(</span><span class="hl kwa">unchecked-add</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> key <span class="hl num">2</span><span class="hl opt">)</span>
                                                             new-first-char-code<span class="hl opt">)))]</span>
          <span class="hl opt">(</span>.set-key<span class="hl opt">!</span> fragment new-key<span class="hl opt">)</span>
          <span class="hl opt">(</span><span class="hl kwa">if-let</span> <span class="hl opt">[</span>^Fragment cur-fragment <span class="hl opt">(</span><span class="hl kwa">get</span> tally fragment<span class="hl opt">)]</span>
            <span class="hl opt">(</span><span class="hl kwa">do</span>
              <span class="hl opt">(</span>.inc<span class="hl opt">!</span> cur-fragment<span class="hl opt">)</span>
              <span class="hl opt">(</span><span class="hl kwa">recur</span> new-offset new-key tally fragment<span class="hl opt">))</span>
            <span class="hl opt">(</span><span class="hl kwa">do</span>
              <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>new-fragment <span class="hl opt">(</span><span class="hl kwa">Fragment</span>. <span class="hl opt">(</span><span class="hl kwa">long</span> <span class="hl num">0</span><span class="hl opt">) (</span><span class="hl kwa">int</span> <span class="hl num">1</span><span class="hl opt">))]</span>
                <span class="hl opt">(</span>.put tally fragment fragment<span class="hl opt">)</span>
                <span class="hl opt">(</span><span class="hl kwa">recur</span> new-offset new-key tally new-fragment<span class="hl opt">)))))))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> ^<span class="hl opt">:</span>static getcnt ^long <span class="hl opt">[</span>^Fragment tc<span class="hl opt">]</span>
  <span class="hl opt">(</span>.get-count tc<span class="hl opt">))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> ^<span class="hl opt">:</span>static tally-total <span class="hl opt">[</span>tally<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>acc <span class="hl opt">(</span><span class="hl kwa">long</span> <span class="hl num">0</span><span class="hl opt">)</span>
         s <span class="hl opt">(</span><span class="hl kwa">vals</span> tally<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">if-let</span> <span class="hl opt">[</span>v <span class="hl opt">(</span><span class="hl kwa">first</span> s<span class="hl opt">)]</span>
      <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(+</span> acc <span class="hl opt">(</span><span class="hl kwa">getcnt</span> v<span class="hl opt">)) (</span><span class="hl kwa">next</span> s<span class="hl opt">))</span>
      acc<span class="hl opt">)))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> all-tally-to-str <span class="hl opt">[</span>tally fn-key-to-str<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">with-out-str</span>
    <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>total <span class="hl opt">(</span><span class="hl kwa">tally-total</span> tally<span class="hl opt">)</span>
          cmp-keys <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>k1 k2<span class="hl opt">]</span>
                     <span class="hl slc">;; Return negative integer if k1 should come earlier</span>
                     <span class="hl slc">;; in the sort order than k2, 0 if they are equal,</span>
                     <span class="hl slc">;; otherwise a positive integer.</span>
                     <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>cnt1 <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">getcnt</span> <span class="hl opt">(</span><span class="hl kwa">get</span> tally k1<span class="hl opt">)))</span>
                           cnt2 <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">getcnt</span> <span class="hl opt">(</span><span class="hl kwa">get</span> tally k2<span class="hl opt">)))]</span>
                       <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">not</span><span class="hl opt">=</span> cnt1 cnt2<span class="hl opt">)</span>
                         <span class="hl opt">(</span><span class="hl kwa">-</span> cnt2 cnt1<span class="hl opt">)</span>
                         <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^String s1 <span class="hl opt">(</span><span class="hl kwa">fn-key-to-str</span> k1<span class="hl opt">)</span>
                               ^String s2 <span class="hl opt">(</span><span class="hl kwa">fn-key-to-str</span> k2<span class="hl opt">)]</span>
                           <span class="hl opt">(</span>.compareTo s1 s2<span class="hl opt">)))))]</span>
      <span class="hl opt">(</span><span class="hl kwa">doseq</span> <span class="hl opt">[</span>k <span class="hl opt">(</span><span class="hl kwa">sort</span> cmp-keys <span class="hl opt">(</span><span class="hl kwa">keys</span> tally<span class="hl opt">))]</span>
        <span class="hl opt">(</span><span class="hl kwa">printf</span> <span class="hl str">&quot;%s %.3f</span><span class="hl esc">\n</span><span class="hl str">&quot;</span> <span class="hl opt">(</span><span class="hl kwa">fn-key-to-str</span> k<span class="hl opt">)</span>
                <span class="hl opt">(</span><span class="hl kwa">double</span> <span class="hl opt">(*</span> <span class="hl num">100</span> <span class="hl opt">(/ (</span><span class="hl kwa">getcnt</span> <span class="hl opt">(</span><span class="hl kwa">get</span> tally k<span class="hl opt">))</span> total<span class="hl opt">))))))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> one-tally-to-str <span class="hl opt">[</span>dna-str tallies<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>zerotc <span class="hl opt">(</span><span class="hl kwa">Fragment</span>. <span class="hl num">0 0</span><span class="hl opt">)</span>
        ^Fragment f <span class="hl opt">(</span><span class="hl kwa">Fragment</span>. <span class="hl opt">(</span><span class="hl kwa">long</span> <span class="hl opt">(</span><span class="hl kwa">dna-str-to-key</span> dna-str<span class="hl opt">))</span> <span class="hl num">0</span><span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">format</span> <span class="hl str">&quot;%d</span><span class="hl esc">\t</span><span class="hl str">%s&quot;</span> <span class="hl opt">(</span><span class="hl kwa">reduce</span> <span class="hl opt">+ (</span><span class="hl kwa">map</span> <span class="hl opt">#(</span><span class="hl kwa">getcnt</span> <span class="hl opt">(</span><span class="hl kwa">get</span> % f zerotc<span class="hl opt">))</span>
                                    tallies<span class="hl opt">))</span>
            dna-str<span class="hl opt">)))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> piece-sizes <span class="hl opt">[</span>total-units n-pieces<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>min-units-per-piece <span class="hl opt">(</span><span class="hl kwa">quot</span> total-units n-pieces<span class="hl opt">)</span>
        n-pieces-with-1-extra <span class="hl opt">(</span><span class="hl kwa">mod</span> total-units n-pieces<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">take</span> n-pieces <span class="hl opt">(</span><span class="hl kwa">concat</span> <span class="hl opt">(</span><span class="hl kwa">repeat</span> n-pieces-with-1-extra
                                   <span class="hl opt">(</span><span class="hl kwa">inc</span> min-units-per-piece<span class="hl opt">))</span>
                           <span class="hl opt">(</span><span class="hl kwa">repeat</span> min-units-per-piece<span class="hl opt">)))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> break-work-into-pieces <span class="hl opt">[{:</span>keys <span class="hl opt">[</span>kind n-pieces<span class="hl opt">] :</span>as m<span class="hl opt">}</span> dna-str<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>substr-len <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(=</span> kind <span class="hl opt">:</span>tally-all<span class="hl opt">) (:</span>substr-len m<span class="hl opt">) (</span><span class="hl kwa">count</span> <span class="hl opt">(:</span>substr m<span class="hl opt">)))</span>
        n-substrs <span class="hl opt">(</span><span class="hl kwa">inc</span> <span class="hl opt">(</span><span class="hl kwa">-</span> <span class="hl opt">(</span><span class="hl kwa">count</span> dna-str<span class="hl opt">)</span> substr-len<span class="hl opt">))</span>
        sizes <span class="hl opt">(</span><span class="hl kwa">piece-sizes</span> n-substrs n-pieces<span class="hl opt">)</span>
        start-end-offsets <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[[</span>a b<span class="hl opt">]] [</span>a <span class="hl opt">(</span><span class="hl kwa">dec</span> b<span class="hl opt">)])</span>
                               <span class="hl opt">(</span><span class="hl kwa">partition</span> <span class="hl num">2 1</span> <span class="hl opt">(</span><span class="hl kwa">cons</span> <span class="hl num">0</span> <span class="hl opt">(</span><span class="hl kwa">reductions</span> <span class="hl opt">+</span> sizes<span class="hl opt">))))]</span>
    <span class="hl opt">(</span><span class="hl kwa">assert</span> <span class="hl opt">(=</span> n-substrs <span class="hl opt">(</span><span class="hl kwa">reduce</span> <span class="hl opt">+</span> sizes<span class="hl opt">)))</span>
    <span class="hl opt">(</span><span class="hl kwa">for</span> <span class="hl opt">[[</span>start end<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">] (</span><span class="hl kwa">partition</span> <span class="hl num">2 1</span> <span class="hl opt">(</span><span class="hl kwa">cons</span> <span class="hl num">0</span> <span class="hl opt">(</span><span class="hl kwa">reductions</span> <span class="hl opt">+</span> sizes<span class="hl opt">)))]</span>
      <span class="hl opt">(</span><span class="hl kwa">assoc</span> m <span class="hl opt">:</span>substr-len substr-len
             <span class="hl opt">:</span>dna-str dna-str
             <span class="hl opt">:</span>start-offset start
             <span class="hl opt">:</span>end-offset <span class="hl opt">(</span><span class="hl kwa">dec</span> end<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">)))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> do-one-piece <span class="hl opt">[{:</span>keys <span class="hl opt">[</span>substr-len dna-str start-offset end-offset<span class="hl opt">] :</span>as m<span class="hl opt">}]</span>
  <span class="hl opt">(</span><span class="hl kwa">assoc</span> m <span class="hl opt">:</span>tally-table <span class="hl opt">(</span><span class="hl kwa">tally-dna-subs-with-len</span> substr-len dna-str
                          start-offset end-offset<span class="hl opt">)))</span>

<span class="hl slc">;; Like merge-with, except it only works for the HashMaps with</span>
<span class="hl slc">;; Fragments as key/value pairs.  It mutates the first HashMap given</span>
<span class="hl slc">;; in place, and potentially some of the Fragments in all of the</span>
<span class="hl slc">;; hashmaps.</span>
<span class="hl opt">(</span><span class="hl kwa">defn</span> add-tally-hashmaps<span class="hl opt">! [</span>hmaps<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>merge-entry <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>^java.util.HashMap hm e<span class="hl opt">]</span>
                      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>k <span class="hl opt">(</span><span class="hl kwa">key</span> e<span class="hl opt">)</span> v <span class="hl opt">(</span><span class="hl kwa">val</span> e<span class="hl opt">)]</span>
                        <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">contains</span>? hm k<span class="hl opt">)</span>
                          <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^Fragment cur-fragment <span class="hl opt">(</span><span class="hl kwa">get</span> hm k<span class="hl opt">)</span>
                                n <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">getcnt</span> v<span class="hl opt">))]</span>
                            <span class="hl opt">(</span>.add<span class="hl opt">!</span> cur-fragment n<span class="hl opt">))</span>
                          <span class="hl opt">(</span>.put hm k v<span class="hl opt">)))</span>
                      hm<span class="hl opt">)</span>
        merge2 <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>hm1 hm2<span class="hl opt">]</span>
                 <span class="hl opt">(</span><span class="hl kwa">reduce</span> merge-entry hm1 <span class="hl opt">(</span><span class="hl kwa">seq</span> hm2<span class="hl opt">)))]</span>
    <span class="hl opt">(</span><span class="hl kwa">reduce</span> merge2 hmaps<span class="hl opt">)))</span>


<span class="hl slc">;; Combine pieces with same :substr-len into one final result</span>
<span class="hl slc">;;</span>
<span class="hl slc">;; For :tally-all, this should combine multiple tally tables into one</span>
<span class="hl slc">;; combined table, then print out the contents of the table.</span>
<span class="hl slc">;;</span>
<span class="hl slc">;; For :tally-one, this should extract out the counts for the one</span>
<span class="hl slc">;; desired string from each table, sum them, and print that result.</span>
<span class="hl slc">;; TBD: Is it within the rules to do that, or must it produce as an</span>
<span class="hl slc">;; intermediate result one hash table that is the sum of all of the</span>
<span class="hl slc">;; partial hash tables?</span>
<span class="hl opt">(</span><span class="hl kwa">defn</span> combine-pieces <span class="hl opt">[</span>pieces<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>p <span class="hl opt">(</span><span class="hl kwa">first</span> pieces<span class="hl opt">)</span>
        kind <span class="hl opt">(:</span>kind p<span class="hl opt">)</span>
        substr-len <span class="hl opt">(:</span>substr-len p<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">case</span> kind
      <span class="hl opt">:</span>tally-all <span class="hl opt">{:</span>substr-len substr-len
                  <span class="hl opt">:</span>output <span class="hl opt">(</span><span class="hl kwa">all-tally-to-str</span>
                           <span class="hl opt">(</span><span class="hl kwa">add-tally-hashmaps</span><span class="hl opt">! (</span><span class="hl kwa">map</span> <span class="hl opt">:</span>tally-table pieces<span class="hl opt">))</span>
                           <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>k<span class="hl opt">] (</span><span class="hl kwa">key-to-dna-str</span> k substr-len<span class="hl opt">)))}</span>
      <span class="hl opt">:</span>tally-one <span class="hl opt">{:</span>substr-len substr-len
                  <span class="hl opt">:</span>output <span class="hl opt">(</span><span class="hl kwa">one-tally-to-str</span> <span class="hl opt">(:</span>substr p<span class="hl opt">)</span>
                                            <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">:</span>tally-table pieces<span class="hl opt">))})))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> run <span class="hl opt">[</span>br<span class="hl opt">]</span>  
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>n-threads <span class="hl opt">(</span>.. Runtime getRuntime availableProcessors<span class="hl opt">)</span>
        dna-str <span class="hl opt">(</span><span class="hl kwa">fasta-dna-str-with-desc-beginning</span> <span class="hl str">&quot;THREE&quot;</span> <span class="hl opt">(</span><span class="hl kwa">line-seq</span> br<span class="hl opt">))</span>
        work-pieces-todo
        <span class="hl opt">(</span><span class="hl kwa">mapcat</span> <span class="hl opt">#(</span><span class="hl kwa">break-work-into-pieces</span> % dna-str<span class="hl opt">)</span>
                <span class="hl opt">[{:</span>kind <span class="hl opt">:</span>tally-all <span class="hl opt">:</span>n-pieces <span class="hl num">1</span> <span class="hl opt">:</span>substr-len <span class="hl num">1</span><span class="hl opt">}</span>
                 <span class="hl opt">{:</span>kind <span class="hl opt">:</span>tally-all <span class="hl opt">:</span>n-pieces <span class="hl num">1</span> <span class="hl opt">:</span>substr-len <span class="hl num">2</span><span class="hl opt">}</span>
                 <span class="hl opt">{:</span>kind <span class="hl opt">:</span>tally-one <span class="hl opt">:</span>n-pieces <span class="hl num">2</span> <span class="hl opt">:</span>substr <span class="hl str">&quot;GGT&quot;</span><span class="hl opt">}</span>
                 <span class="hl opt">{:</span>kind <span class="hl opt">:</span>tally-one <span class="hl opt">:</span>n-pieces <span class="hl num">2</span> <span class="hl opt">:</span>substr <span class="hl str">&quot;GGTA&quot;</span><span class="hl opt">}</span>
                 <span class="hl opt">{:</span>kind <span class="hl opt">:</span>tally-one <span class="hl opt">:</span>n-pieces <span class="hl num">3</span> <span class="hl opt">:</span>substr <span class="hl str">&quot;GGTATT&quot;</span><span class="hl opt">}</span>
                 <span class="hl opt">{:</span>kind <span class="hl opt">:</span>tally-one <span class="hl opt">:</span>n-pieces <span class="hl num">3</span> <span class="hl opt">:</span>substr <span class="hl str">&quot;GGTATTTTAATT&quot;</span><span class="hl opt">}</span>
                 <span class="hl opt">{:</span>kind <span class="hl opt">:</span>tally-one <span class="hl opt">:</span>n-pieces <span class="hl num">4</span> <span class="hl opt">:</span>substr <span class="hl str">&quot;GGTATTTTAATTTATAGT&quot;</span><span class="hl opt">}])</span>
        work-pieces-done <span class="hl opt">(</span><span class="hl kwa">medusa-pmap</span> n-threads do-one-piece work-pieces-todo<span class="hl opt">)</span>
        grouped-results <span class="hl opt">(</span><span class="hl kwa">partition-by</span> <span class="hl opt">:</span>substr-len work-pieces-done<span class="hl opt">)</span>
        combined-results <span class="hl opt">(</span><span class="hl kwa">pmap</span> combine-pieces grouped-results<span class="hl opt">)</span>
        results <span class="hl opt">(</span><span class="hl kwa">sort-by</span> <span class="hl opt">:</span>substr-len combined-results<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">doseq</span> <span class="hl opt">[</span>r results<span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">println</span> <span class="hl opt">(:</span>output r<span class="hl opt">))</span>
      <span class="hl opt">(</span><span class="hl kwa">flush</span><span class="hl opt">))))</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> -main <span class="hl opt">[&amp;</span> args<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">with-open</span> <span class="hl opt">[</span>br <span class="hl opt">(</span><span class="hl kwa">java</span>.io.BufferedReader. <span class="hl opt">*</span>in<span class="hl opt">*)]</span>
    <span class="hl opt">(</span><span class="hl kwa">run</span> br<span class="hl opt">))</span>  
  <span class="hl opt">(</span><span class="hl kwa">shutdown-agents</span><span class="hl opt">)</span>
  <span class="hl opt">(</span><span class="hl kwa">shutdown-medusa</span><span class="hl opt">))</span>
