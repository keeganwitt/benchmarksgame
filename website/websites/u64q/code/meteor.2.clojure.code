<span class="hl slc">;; The Computer Language Benchmarks Game</span>
<span class="hl slc">;; http://benchmarksgame.alioth.debian.org/</span>
<span class="hl slc">;;</span>
<span class="hl slc">;; contributed by Andy Fingerhut</span>
<span class="hl slc">;; Based upon ideas from GCC version by Christian Vosteen (good comments!)</span>

<span class="hl slc">;; This version is intended only to run on Clojure 1.3.  It does not</span>
<span class="hl slc">;; run on Clojure 1.2.  Lots of type hints removed from Clojure 1.2</span>
<span class="hl slc">;; version, but it is still very close to the same speed due to 1.3's</span>
<span class="hl slc">;; primitive support.</span>

<span class="hl opt">(</span><span class="hl kwa">ns</span> meteor
  <span class="hl opt">(:</span>gen-class<span class="hl opt">)</span>
  <span class="hl opt">(:</span>require <span class="hl opt">[</span>clojure.string <span class="hl opt">:</span>as str<span class="hl opt">])</span>
  <span class="hl opt">(:</span>require <span class="hl opt">[</span>clojure.pprint <span class="hl opt">:</span>as pprint<span class="hl opt">]))</span>

<span class="hl opt">(</span><span class="hl kwa">set</span><span class="hl opt">! *</span>warn-on-reflection<span class="hl opt">*</span> true<span class="hl opt">)</span>


<span class="hl slc">;; The board is a 50 cell hexagonal pattern.  For    . . . . .</span>
<span class="hl slc">;; maximum speed the board will be implemented as     . . . . .</span>
<span class="hl slc">;; 50 bits, which will fit into 2 32-bit ints.       . . . . .</span>
<span class="hl slc">;; I originally tried 1 64-bit long, but the bit-*    . . . . .</span>
<span class="hl slc">;; operators in Clojure 1.2 are not as optimized     . . . . .</span>
<span class="hl slc">;; as they will be in the next version of Clojure.    . . . . .</span>
<span class="hl slc">;;                                                   . . . . .</span>
<span class="hl slc">;;                                                    . . . . .</span>
<span class="hl slc">;; I will represent 0's as empty cells and 1's       . . . . .</span>
<span class="hl slc">;; as full cells.                                     . . . . .</span>

<span class="hl slc">;; Here are the numerical indices for each position on the board, also</span>
<span class="hl slc">;; later called board indices.</span>
<span class="hl slc">;;</span>
<span class="hl slc">;;  0   1   2   3   4</span>
<span class="hl slc">;;    5   6   7   8   9</span>
<span class="hl slc">;; 10  11  12  13  14</span>
<span class="hl slc">;;   15  16  17  18  19</span>
<span class="hl slc">;; 20  21  22  23  24</span>
<span class="hl slc">;;   25  26  27  28  29</span>
<span class="hl slc">;; 30  31  32  33  34</span>
<span class="hl slc">;;   35  36  37  38  39</span>
<span class="hl slc">;; 40  41  42  43  44</span>
<span class="hl slc">;;   45  46  47  48  49</span>


<span class="hl slc">;; Numerical encodings of directions:</span>
<span class="hl slc">;; 0 East, 1 Southeast, 2 Southwest, 3 West, 4 Northwest, 5 Northeast</span>

<span class="hl slc">;; Each puzzle piece is specified as a tree.  Every piece consists of</span>
<span class="hl slc">;; 5 'nodes', each of which occupies one board index.  Each piece has</span>
<span class="hl slc">;; a root node numbered 0, and every other node (numbered 1 through 4)</span>
<span class="hl slc">;; specifies its parent node, and the direction to take to get from</span>
<span class="hl slc">;; the parent to the child (in a default orientation).</span>

<span class="hl slc">;; In the pictures below, pieces are shown graphically in their</span>
<span class="hl slc">;; default orientation, with nodes numbered 0 through 4.</span>

<span class="hl slc">;;   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4</span>
<span class="hl slc">;;                   </span>
<span class="hl slc">;;  0 1 2 3    0   3 4   0 1 2     0 1 2     0   3</span>
<span class="hl slc">;;         4    1 2           3       3       1 2</span>
<span class="hl slc">;;                           4         4         4</span>
<span class="hl slc">;;</span>
<span class="hl opt">(</span><span class="hl kwa">def</span> piece-defs <span class="hl opt">[ [[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 0</span><span class="hl opt">] [</span><span class="hl num">2 0</span><span class="hl opt">] [</span><span class="hl num">3 1</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 0</span>
<span class="hl slc">;;                 ^^^^^ node 1 is East (direction 0) of its parent node 0</span>
<span class="hl slc">;;                       ^^^^^ node 2 is East of its parent node 1</span>
                  <span class="hl opt">[[</span><span class="hl num">0 1</span><span class="hl opt">] [</span><span class="hl num">1 0</span><span class="hl opt">] [</span><span class="hl num">2 5</span><span class="hl opt">] [</span><span class="hl num">3 0</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 1</span>
                  <span class="hl opt">[[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 0</span><span class="hl opt">] [</span><span class="hl num">2 1</span><span class="hl opt">] [</span><span class="hl num">3 2</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 2</span>
                  <span class="hl opt">[[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 0</span><span class="hl opt">] [</span><span class="hl num">2 2</span><span class="hl opt">] [</span><span class="hl num">3 1</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 3</span>
                  <span class="hl opt">[[</span><span class="hl num">0 1</span><span class="hl opt">] [</span><span class="hl num">1 0</span><span class="hl opt">] [</span><span class="hl num">2 5</span><span class="hl opt">] [</span><span class="hl num">2 1</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 4</span>
<span class="hl slc">;;                                    ^ node 4's parent is 2, not 3</span>
<span class="hl slc">;;</span>
<span class="hl slc">;;   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9</span>
<span class="hl slc">;;</span>
<span class="hl slc">;;    0 1 2     0 1       0 1     0 1        0 1 2 3</span>
<span class="hl slc">;;       3 4       2 4       2       2 3 4        4</span>
<span class="hl slc">;;                  3       4 3</span>
<span class="hl slc">;;</span>
                  <span class="hl opt">[[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 0</span><span class="hl opt">] [</span><span class="hl num">2 2</span><span class="hl opt">] [</span><span class="hl num">3 0</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 5</span>
                  <span class="hl opt">[[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 1</span><span class="hl opt">] [</span><span class="hl num">2 1</span><span class="hl opt">] [</span><span class="hl num">3 5</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 6</span>
                  <span class="hl opt">[[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 1</span><span class="hl opt">] [</span><span class="hl num">2 1</span><span class="hl opt">] [</span><span class="hl num">3 3</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 7</span>
                  <span class="hl opt">[[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 1</span><span class="hl opt">] [</span><span class="hl num">2 0</span><span class="hl opt">] [</span><span class="hl num">3 0</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 8</span>
                  <span class="hl opt">[[</span><span class="hl num">0 0</span><span class="hl opt">] [</span><span class="hl num">1 0</span><span class="hl opt">] [</span><span class="hl num">2 0</span><span class="hl opt">] [</span><span class="hl num">3 2</span><span class="hl opt">]]</span>  <span class="hl slc">; piece 9</span>
                  <span class="hl opt">])</span>

<span class="hl slc">;; Unlike Christian Vosteen's C program, I will only use 6 directions:</span>
<span class="hl slc">;;</span>
<span class="hl slc">;; E SE SW W NW NE</span>
<span class="hl slc">;;</span>
<span class="hl slc">;; I will use a different representation for piece shapes so that I</span>
<span class="hl slc">;; won't need 12 directions for the reason that he introduced them</span>
<span class="hl slc">;; (i.e. pieces whose shapes are like a tree, and cannot be</span>
<span class="hl slc">;; represented only with a sequence of directions from one starting</span>
<span class="hl slc">;; point).</span>


<span class="hl slc">;; To minimize the amount of work done in the recursive solve function</span>
<span class="hl slc">;; below, I'm going to precalculate all legal rotations of each piece</span>
<span class="hl slc">;; at each position on the board. That's 10 pieces x 50 board</span>
<span class="hl slc">;; positions x 6 rotations x 2 'flip positions' ('top side up' or 'top</span>
<span class="hl slc">;; side down').  However, not all 6x2=12 orientations will fit on</span>
<span class="hl slc">;; every cell.  Only keep the ones that do.  The pieces are going to</span>
<span class="hl slc">;; be pairs of 32-bit ints just like the board so they can be</span>
<span class="hl slc">;; bitwise-anded with the board to determine if they fit.  I'm also</span>
<span class="hl slc">;; going to record the next possible open cell for each piece and</span>
<span class="hl slc">;; location to reduce the burden on the solve function.</span>


<span class="hl slc">;; Returns the direction rotated 60 degrees clockwise</span>
<span class="hl opt">(</span><span class="hl kwa">defn</span> rotate <span class="hl opt">[</span>dir<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">case</span> <span class="hl opt">(</span><span class="hl kwa">int</span> dir<span class="hl opt">)</span>
        <span class="hl num">0 1</span>
        <span class="hl num">1 2</span>
        <span class="hl num">2 3</span>
        <span class="hl num">3 4</span>
        <span class="hl num">4 5</span>
        <span class="hl num">5 0</span><span class="hl opt">))</span>

<span class="hl slc">;; Returns the direction flipped on the horizontal axis</span>
<span class="hl opt">(</span><span class="hl kwa">defn</span> flip <span class="hl opt">[</span>dir<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">case</span> <span class="hl opt">(</span><span class="hl kwa">int</span> dir<span class="hl opt">)</span>
        <span class="hl num">0 0</span>
        <span class="hl num">1 5</span>
        <span class="hl num">2 4</span>
        <span class="hl num">3 3</span>
        <span class="hl num">4 2</span>
        <span class="hl num">5 1</span><span class="hl opt">))</span>


<span class="hl slc">;; Returns the new cell index from the specified cell in the specified</span>
<span class="hl slc">;; direction.  The index is only valid if the starting cell and</span>
<span class="hl slc">;; direction have been checked by the out-of-bounds function first.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> shift <span class="hl opt">[</span>cell dir<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">case</span> <span class="hl opt">(</span><span class="hl kwa">int</span> dir<span class="hl opt">)</span>
        <span class="hl num">0</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> cell<span class="hl opt">)</span>
        <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">odd</span>? <span class="hl opt">(</span><span class="hl kwa">quot</span> cell <span class="hl num">5</span><span class="hl opt">))</span>
              <span class="hl opt">(+</span> cell <span class="hl num">6</span><span class="hl opt">)</span>
              <span class="hl opt">(+</span> cell <span class="hl num">5</span><span class="hl opt">))</span>
        <span class="hl num">2</span> <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">odd</span>? <span class="hl opt">(</span><span class="hl kwa">quot</span> cell <span class="hl num">5</span><span class="hl opt">))</span>
              <span class="hl opt">(+</span> cell <span class="hl num">5</span><span class="hl opt">)</span>
              <span class="hl opt">(+</span> cell <span class="hl num">4</span><span class="hl opt">))</span>
        <span class="hl num">3</span>  <span class="hl opt">(</span><span class="hl kwa">dec</span> cell<span class="hl opt">)</span>
        <span class="hl num">4</span> <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">odd</span>? <span class="hl opt">(</span><span class="hl kwa">quot</span> cell <span class="hl num">5</span><span class="hl opt">))</span>
              <span class="hl opt">(</span><span class="hl kwa">-</span> cell <span class="hl num">5</span><span class="hl opt">)</span>
              <span class="hl opt">(</span><span class="hl kwa">-</span> cell <span class="hl num">6</span><span class="hl opt">))</span>
        <span class="hl num">5</span> <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">odd</span>? <span class="hl opt">(</span><span class="hl kwa">quot</span> cell <span class="hl num">5</span><span class="hl opt">))</span>
              <span class="hl opt">(</span><span class="hl kwa">-</span> cell <span class="hl num">4</span><span class="hl opt">)</span>
              <span class="hl opt">(</span><span class="hl kwa">-</span> cell <span class="hl num">5</span><span class="hl opt">))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> make-shift-table <span class="hl opt">[]</span>
  <span class="hl opt">(</span><span class="hl kwa">object-array</span> <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>cell-idx<span class="hl opt">]</span>
                       <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>dir<span class="hl opt">] (</span><span class="hl kwa">shift</span> cell-idx dir<span class="hl opt">))</span>
                                        <span class="hl opt">(</span><span class="hl kwa">range</span> <span class="hl num">6</span><span class="hl opt">))))</span>
                     <span class="hl opt">(</span><span class="hl kwa">range</span> <span class="hl num">50</span><span class="hl opt">))))</span>


<span class="hl slc">;; Returns wether the specified cell and direction will land outside</span>
<span class="hl slc">;; of the board.  Used to determine if a piece is at a legal board</span>
<span class="hl slc">;; location or not.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> out-of-bounds <span class="hl opt">[</span>cell dir<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">case</span> <span class="hl opt">(</span><span class="hl kwa">int</span> dir<span class="hl opt">)</span>
        <span class="hl num">0</span> <span class="hl opt">(== (</span><span class="hl kwa">rem</span> cell <span class="hl num">5</span><span class="hl opt">)</span> <span class="hl num">4</span><span class="hl opt">)</span>       <span class="hl slc">; cell is on the right side</span>
        <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">or</span> <span class="hl opt">(== (</span><span class="hl kwa">rem</span> cell <span class="hl num">10</span><span class="hl opt">)</span> <span class="hl num">9</span><span class="hl opt">)</span>  <span class="hl slc">; cell is on &quot;extreme&quot; right side</span>
              <span class="hl opt">(&gt;=</span> cell <span class="hl num">45</span><span class="hl opt">))</span>         <span class="hl slc">; or the bottom row</span>
        <span class="hl num">2</span> <span class="hl opt">(</span><span class="hl kwa">or</span> <span class="hl opt">(== (</span><span class="hl kwa">rem</span> cell <span class="hl num">10</span><span class="hl opt">)</span> <span class="hl num">0</span><span class="hl opt">)</span>  <span class="hl slc">; cell is on &quot;extreme&quot; left side</span>
              <span class="hl opt">(&gt;=</span> cell <span class="hl num">45</span><span class="hl opt">))</span>         <span class="hl slc">; or the bottom row</span>
        <span class="hl num">3</span> <span class="hl opt">(== (</span><span class="hl kwa">rem</span> cell <span class="hl num">5</span><span class="hl opt">)</span> <span class="hl num">0</span><span class="hl opt">)</span>       <span class="hl slc">; cell is on the left side</span>
        <span class="hl num">4</span> <span class="hl opt">(</span><span class="hl kwa">or</span> <span class="hl opt">(== (</span><span class="hl kwa">rem</span> cell <span class="hl num">10</span><span class="hl opt">)</span> <span class="hl num">0</span><span class="hl opt">)</span>  <span class="hl slc">; cell is on &quot;extreme&quot; left side</span>
              <span class="hl opt">(&lt;</span> cell <span class="hl num">5</span><span class="hl opt">))</span>           <span class="hl slc">; or the top row</span>
        <span class="hl num">5</span> <span class="hl opt">(</span><span class="hl kwa">or</span> <span class="hl opt">(== (</span><span class="hl kwa">rem</span> cell <span class="hl num">10</span><span class="hl opt">)</span> <span class="hl num">9</span><span class="hl opt">)</span>  <span class="hl slc">; cell is on &quot;extreme&quot; right side</span>
              <span class="hl opt">(&lt;</span> cell <span class="hl num">5</span><span class="hl opt">))))</span>         <span class="hl slc">; or the top row</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> make-oob-table <span class="hl opt">[]</span>
  <span class="hl opt">(</span><span class="hl kwa">object-array</span> <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>cell-idx<span class="hl opt">]</span>
                       <span class="hl opt">(</span><span class="hl kwa">boolean-array</span> <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>dir<span class="hl opt">] (</span><span class="hl kwa">out-of-bounds</span> cell-idx dir<span class="hl opt">))</span>
                                           <span class="hl opt">(</span><span class="hl kwa">range</span> <span class="hl num">6</span><span class="hl opt">))))</span>
                     <span class="hl opt">(</span><span class="hl kwa">range</span> <span class="hl num">50</span><span class="hl opt">))))</span>


<span class="hl slc">;; Return a piece that is the the same as the one given as argument,</span>
<span class="hl slc">;; except rotated 60 degrees clockwise.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> rotate-piece <span class="hl opt">[</span>piece<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">vec</span> <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[[</span>parent dir<span class="hl opt">]] [</span>parent <span class="hl opt">(</span><span class="hl kwa">rotate</span> dir<span class="hl opt">)])</span> piece<span class="hl opt">)))</span>


<span class="hl slc">;; Return a piece that is the the same as the one given as argument,</span>
<span class="hl slc">;; except flipped along the horizontal axis.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> flip-piece <span class="hl opt">[</span>piece<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">vec</span> <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[[</span>parent dir<span class="hl opt">]] [</span>parent <span class="hl opt">(</span><span class="hl kwa">flip</span> dir<span class="hl opt">)])</span> piece<span class="hl opt">)))</span>


<span class="hl slc">;; Convenience function to calculate and return a vector of all of the</span>
<span class="hl slc">;; board indices that a piece's nodes will be in, if that piece's root</span>
<span class="hl slc">;; node is at root-index.</span>

<span class="hl slc">;; Note that no check is made to see whether the piece actually fits</span>
<span class="hl slc">;; on the board or not, so some of the returned index values may be</span>
<span class="hl slc">;; nonsense.  See cells-fit-on-board for a way to check this.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> calc-cell-indices <span class="hl opt">[</span>piece root-index ^objects shift-table<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>indices <span class="hl opt">(</span><span class="hl kwa">transient</span> <span class="hl opt">[</span>root-index<span class="hl opt">])</span>
         node <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">0</span><span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(==</span> node <span class="hl num">4</span><span class="hl opt">)</span>
      <span class="hl opt">(</span><span class="hl kwa">persistent</span><span class="hl opt">!</span> indices<span class="hl opt">)</span>
      <span class="hl slc">;; else</span>
      <span class="hl slc">;; Note that information about node n of a piece is in (piece</span>
      <span class="hl slc">;; (dec n)) We're intentionally iterating the value 'node' 0</span>
      <span class="hl slc">;; through 3 rather than 1 through 4 here just to avoid</span>
      <span class="hl slc">;; calculating (dec node) here.</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>pair <span class="hl opt">(</span><span class="hl kwa">piece</span> node<span class="hl opt">)</span>
            parent <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">pair</span> <span class="hl num">0</span><span class="hl opt">))</span>
            dir <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">pair</span> <span class="hl num">1</span><span class="hl opt">))</span>
            <span class="hl slc">;[parent dir] (piece node)</span>
            parent-loc <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">indices</span> parent<span class="hl opt">))]</span>
        <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">conj</span><span class="hl opt">!</span> indices
                      <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">and</span> <span class="hl opt">(&lt;</span> parent-loc <span class="hl num">50</span><span class="hl opt">) (</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">neg</span>? parent-loc<span class="hl opt">)))</span>
                        <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^longs shift-table-for-parent-loc
                              <span class="hl opt">(</span><span class="hl kwa">aget</span> shift-table parent-loc<span class="hl opt">)]</span>
                          <span class="hl opt">(</span><span class="hl kwa">aget</span> shift-table-for-parent-loc dir<span class="hl opt">))</span>
                        <span class="hl num">0</span><span class="hl opt">))</span>  <span class="hl slc">;; dummy value</span>
               <span class="hl opt">(</span><span class="hl kwa">inc</span> node<span class="hl opt">))))))</span>


<span class="hl slc">;; Convenience function to calculate if a piece fits on the board.</span>
<span class="hl slc">;; Node 0 of the piece, at board index (indices 0), is assumed to be</span>
<span class="hl slc">;; on the board, but the other nodes may be off.</span>

<span class="hl opt">(</span><span class="hl kwa">defmacro</span> node-fits <span class="hl opt">[</span>node-info indices ^objects oob-table<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>pair<span class="hl opt">#</span> ~node-info
         parent-node-num<span class="hl opt"># (</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">pair</span><span class="hl opt">#</span> <span class="hl num">0</span><span class="hl opt">))</span>
         dir<span class="hl opt"># (</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">pair</span><span class="hl opt">#</span> <span class="hl num">1</span><span class="hl opt">))</span>
         parent-idx<span class="hl opt"># (</span><span class="hl kwa">int</span> <span class="hl opt">(</span>~indices parent-node-num<span class="hl opt">#))</span>
         <span class="hl slc">;^booleans oob-for-parent-idx# (aget ~oob-table parent-idx#)]</span>
         ^<span class="hl str">&quot;[Z&quot;</span> oob-for-parent-idx<span class="hl opt"># (</span><span class="hl kwa">aget</span> ~oob-table parent-idx<span class="hl opt">#)]</span>
     <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-for-parent-idx<span class="hl opt">#</span> dir<span class="hl opt">#))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> cells-fit-on-board <span class="hl opt">[</span>piece indices ^objects oob-table<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">and</span>
   <span class="hl opt">(</span><span class="hl kwa">node-fits</span> <span class="hl opt">(</span><span class="hl kwa">piece</span> <span class="hl num">0</span><span class="hl opt">)</span> indices oob-table<span class="hl opt">)</span>  <span class="hl slc">;; check node 1 of the piece</span>
   <span class="hl opt">(</span><span class="hl kwa">node-fits</span> <span class="hl opt">(</span><span class="hl kwa">piece</span> <span class="hl num">1</span><span class="hl opt">)</span> indices oob-table<span class="hl opt">)</span>  <span class="hl slc">;; node 2, etc.</span>
   <span class="hl opt">(</span><span class="hl kwa">node-fits</span> <span class="hl opt">(</span><span class="hl kwa">piece</span> <span class="hl num">2</span><span class="hl opt">)</span> indices oob-table<span class="hl opt">)</span>
   <span class="hl opt">(</span><span class="hl kwa">node-fits</span> <span class="hl opt">(</span><span class="hl kwa">piece</span> <span class="hl num">3</span><span class="hl opt">)</span> indices oob-table<span class="hl opt">)))</span>


<span class="hl slc">;; Fill the entire board going cell by cell, starting from index i.</span>
<span class="hl slc">;; If any cells are &quot;trapped&quot; they will be left alone.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> fill-contiguous-space<span class="hl opt">! [</span>^longs board i
                              ^objects shift-table ^objects oob-table<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">letfn</span>
      <span class="hl opt">[(</span><span class="hl kwa">fill-helper</span><span class="hl opt">! [</span>i<span class="hl opt">]</span>
         <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>i <span class="hl opt">(</span><span class="hl kwa">int</span> i<span class="hl opt">)</span>
               ^booleans oob-table-row <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-table i<span class="hl opt">)</span>
               ^longs shift-table-row <span class="hl opt">(</span><span class="hl kwa">aget</span> shift-table i<span class="hl opt">)]</span>
           <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">aget</span> board i<span class="hl opt">))</span>
             <span class="hl opt">(</span><span class="hl kwa">aset</span> board i <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">1</span><span class="hl opt">))</span>
             <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">0</span><span class="hl opt">)))</span>
               <span class="hl opt">(</span><span class="hl kwa">fill-helper</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> shift-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">0</span><span class="hl opt">))))</span>
             <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">1</span><span class="hl opt">)))</span>
               <span class="hl opt">(</span><span class="hl kwa">fill-helper</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> shift-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">1</span><span class="hl opt">))))</span>
             <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">2</span><span class="hl opt">)))</span>
               <span class="hl opt">(</span><span class="hl kwa">fill-helper</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> shift-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">2</span><span class="hl opt">))))</span>
             <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">3</span><span class="hl opt">)))</span>
               <span class="hl opt">(</span><span class="hl kwa">fill-helper</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> shift-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">3</span><span class="hl opt">))))</span>
             <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">4</span><span class="hl opt">)))</span>
               <span class="hl opt">(</span><span class="hl kwa">fill-helper</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> shift-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">4</span><span class="hl opt">))))</span>
             <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> oob-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">5</span><span class="hl opt">)))</span>
               <span class="hl opt">(</span><span class="hl kwa">fill-helper</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> shift-table-row <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">5</span><span class="hl opt">)))))))]</span>
    <span class="hl opt">(</span><span class="hl kwa">fill-helper</span><span class="hl opt">!</span> i<span class="hl opt">)))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> empty-cells <span class="hl opt">[</span>^longs board-arr<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">-</span> <span class="hl num">50</span>
     <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^longs a board-arr<span class="hl opt">]</span>
       <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>i <span class="hl num">49</span>
              ret <span class="hl num">0</span><span class="hl opt">]</span>
         <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">neg</span>? i<span class="hl opt">)</span>
           ret
           <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">dec</span> i<span class="hl opt">)</span>
                  <span class="hl opt">(+</span> ret <span class="hl opt">(</span><span class="hl kwa">aget</span> a i<span class="hl opt">))))))))</span>


<span class="hl slc">;; Warning: Modifies its argument board-arr</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> board-empty-region-sizes<span class="hl opt">! [</span>^longs board-arr
                                 ^objects shift-table ^objects oob-table<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>sizes <span class="hl opt">(</span><span class="hl kwa">transient</span> <span class="hl opt">[])</span>
         num-empty <span class="hl opt">(</span><span class="hl kwa">empty-cells</span> board-arr<span class="hl opt">)</span>
         last-empty-cell <span class="hl num">50</span><span class="hl opt">]</span>
    <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? num-empty<span class="hl opt">)</span>
      <span class="hl opt">(</span><span class="hl kwa">persistent</span><span class="hl opt">!</span> sizes<span class="hl opt">)</span>
      <span class="hl slc">;; else</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>next-last-empty-cell <span class="hl opt">(</span><span class="hl kwa">long</span> <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>i <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl opt">(</span><span class="hl kwa">dec</span> last-empty-cell<span class="hl opt">))]</span>
                                         <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">aget</span> board-arr i<span class="hl opt">))</span>
                                           i
                                           <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">dec</span> i<span class="hl opt">)))))]</span>
        <span class="hl opt">(</span><span class="hl kwa">fill-contiguous-space</span><span class="hl opt">!</span> board-arr next-last-empty-cell shift-table
                                oob-table<span class="hl opt">)</span>
        <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>next-num-empty <span class="hl opt">(</span><span class="hl kwa">empty-cells</span> board-arr<span class="hl opt">)]</span>
          <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">conj</span><span class="hl opt">!</span> sizes <span class="hl opt">(</span><span class="hl kwa">-</span> num-empty next-num-empty<span class="hl opt">))</span>
                 next-num-empty
                 next-last-empty-cell<span class="hl opt">))))))</span>


<span class="hl slc">;; Generate the pair of longs (of which we only care about the 32</span>
<span class="hl slc">;; lsbs) that will later be anded with the board to determine if it</span>
<span class="hl slc">;; fits.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> bitmask-from-indices <span class="hl opt">[</span>indices<span class="hl opt">]</span>
  <span class="hl opt">[(</span><span class="hl kwa">reduce</span> bit-or <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>i<span class="hl opt">] (</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;</span> i <span class="hl num">25</span><span class="hl opt">) (</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1</span> i<span class="hl opt">)</span> <span class="hl num">0</span><span class="hl opt">))</span>
                       indices<span class="hl opt">))</span>
   <span class="hl opt">(</span><span class="hl kwa">reduce</span> bit-or <span class="hl opt">(</span><span class="hl kwa">map</span> <span class="hl opt">(</span><span class="hl kwa">fn</span> <span class="hl opt">[</span>i<span class="hl opt">] (</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;</span> i <span class="hl num">25</span><span class="hl opt">)</span> <span class="hl num">0</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">-</span> i <span class="hl num">25</span><span class="hl opt">))))</span>
                       indices<span class="hl opt">))])</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> print-board <span class="hl opt">[</span>^longs soln<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">50</span><span class="hl opt">]</span>
    <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">rem</span> i <span class="hl num">5</span><span class="hl opt">))</span>
      <span class="hl opt">(</span><span class="hl kwa">println</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">))</span>
    <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(== (</span><span class="hl kwa">rem</span> i <span class="hl num">10</span><span class="hl opt">)</span> <span class="hl num">5</span><span class="hl opt">)</span>
      <span class="hl opt">(</span><span class="hl kwa">print</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">))</span>
    <span class="hl opt">(</span><span class="hl kwa">printf</span> <span class="hl str">&quot;%d &quot;</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> soln i<span class="hl opt">))))</span>


<span class="hl slc">;; Solutions are encoded as vectors of 50 integers, one for each board</span>
<span class="hl slc">;; index, where each integer is in the range [0,9], representing one</span>
<span class="hl slc">;; of the 5 parts of a piece that is in that board index.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> encode-solution <span class="hl opt">[</span>^longs piece-num-arr ^longs mask-arr0 ^longs mask-arr1<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>soln <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl num">50</span> -<span class="hl num">1</span><span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">25</span><span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>idx-mask <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">1</span><span class="hl opt">)</span> i<span class="hl opt">)]</span>
        <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>p <span class="hl num">0</span><span class="hl opt">]</span>
          <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;</span> p <span class="hl num">10</span><span class="hl opt">)</span>
            <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> mask-arr0 p<span class="hl opt">)</span> idx-mask<span class="hl opt">))</span>
              <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> p<span class="hl opt">))</span>
              <span class="hl opt">(</span><span class="hl kwa">aset</span> soln i <span class="hl opt">(</span><span class="hl kwa">aget</span> piece-num-arr p<span class="hl opt">)))))</span>
        <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>p <span class="hl num">0</span><span class="hl opt">]</span>
          <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;</span> p <span class="hl num">10</span><span class="hl opt">)</span>
            <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> mask-arr1 p<span class="hl opt">)</span> idx-mask<span class="hl opt">))</span>
              <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> p<span class="hl opt">))</span>
              <span class="hl opt">(</span><span class="hl kwa">aset</span> soln <span class="hl opt">(+</span> <span class="hl num">25</span> i<span class="hl opt">) (</span><span class="hl kwa">aget</span> piece-num-arr p<span class="hl opt">)))))))</span>
    soln<span class="hl opt">))</span>


<span class="hl slc">;; To thin the number of pieces, I calculate if any of them trap any</span>
<span class="hl slc">;; empty cells at the edges, such that the number of trapped empty</span>
<span class="hl slc">;; cells is not a multiple of 5.  All pieces have 5 cells, so any such</span>
<span class="hl slc">;; trapped regions cannot possibly be filled with any pieces.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> one-piece-has-island <span class="hl opt">[</span>indices shift-table oob-table<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>temp-board <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl num">50</span><span class="hl opt">)]</span>
    <span class="hl slc">;; Mark the piece board positions as filled</span>
    <span class="hl opt">(</span><span class="hl kwa">doseq</span> <span class="hl opt">[</span>idx indices<span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">aset</span> temp-board idx <span class="hl num">1</span><span class="hl opt">))</span>
    <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>empty-region-sizes <span class="hl opt">(</span><span class="hl kwa">board-empty-region-sizes</span><span class="hl opt">!</span> temp-board shift-table
                                                        oob-table<span class="hl opt">)]</span>
      <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">every</span>? <span class="hl opt">#(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">rem</span> % <span class="hl num">5</span><span class="hl opt">))</span> empty-region-sizes<span class="hl opt">)))))</span>


<span class="hl slc">;; Calculate the lowest possible open cell if the piece is placed on</span>
<span class="hl slc">;; the board.  Used to later reduce the amount of time searching for</span>
<span class="hl slc">;; open cells in the solve function.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> first-empty-cell-after <span class="hl opt">[</span>minimum indices<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>idx-set <span class="hl opt">(</span><span class="hl kwa">set</span> indices<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>i minimum<span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">idx-set</span> i<span class="hl opt">)</span>
        <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> i<span class="hl opt">))</span>
        i<span class="hl opt">))))</span>


<span class="hl slc">;; We calculate only half of piece 3's rotations.  This is because any</span>
<span class="hl slc">;; solution found has an identical solution rotated 180 degrees.  Thus</span>
<span class="hl slc">;; we can reduce the number of attempted pieces in the solve algorithm</span>
<span class="hl slc">;; by not including the 180- degree-rotated pieces of ONE of the</span>
<span class="hl slc">;; pieces.  I chose piece 3 because it gave me the best time ;)</span>

<span class="hl opt">(</span><span class="hl kwa">def</span> <span class="hl opt">+</span>piece-num-to-do-only-3-rotations<span class="hl opt">+</span> <span class="hl num">3</span><span class="hl opt">)</span>

<span class="hl slc">;; Calculate every legal rotation for each piece at each board</span>
<span class="hl slc">;; location.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> calc-pieces <span class="hl opt">[</span>pieces shift-table oob-table<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>npieces <span class="hl opt">(</span><span class="hl kwa">count</span> pieces<span class="hl opt">)</span>
        ^objects tbl <span class="hl opt">(</span><span class="hl kwa">object-array</span> npieces<span class="hl opt">)]</span> <span class="hl slc">; first index is piece-num</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>piece-num npieces<span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">aset</span> tbl piece-num <span class="hl opt">(</span><span class="hl kwa">object-array</span> <span class="hl num">50</span><span class="hl opt">))</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^objects piece-arr <span class="hl opt">(</span><span class="hl kwa">aget</span> tbl piece-num<span class="hl opt">)]</span>
        <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>cell <span class="hl num">50</span><span class="hl opt">]</span>  <span class="hl slc">; second index is board index</span>
          <span class="hl slc">;; Start with transient vectors.  Later we will change them to</span>
          <span class="hl slc">;; Java arrays after we know how long to make them.</span>
          <span class="hl opt">(</span><span class="hl kwa">aset</span> piece-arr cell <span class="hl opt">(</span><span class="hl kwa">transient</span> <span class="hl opt">[])))))</span>
    <span class="hl slc">;; Find all possible good piece placements</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>p npieces<span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>unrotated-piece <span class="hl opt">(</span><span class="hl kwa">pieces</span> p<span class="hl opt">)</span>
            num-rots <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(=</span> p <span class="hl opt">+</span>piece-num-to-do-only-3-rotations<span class="hl opt">+)</span> <span class="hl num">3 6</span><span class="hl opt">)]</span>
        <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>flip <span class="hl num">2</span><span class="hl opt">]</span>
          <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>rot <span class="hl num">0</span>
                 piece <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? flip<span class="hl opt">)</span>
                         unrotated-piece
                         <span class="hl opt">(</span><span class="hl kwa">flip-piece</span> unrotated-piece<span class="hl opt">))]</span>
            <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(&lt;</span> rot num-rots<span class="hl opt">)</span>
              <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>cell <span class="hl num">50</span><span class="hl opt">]</span>
                <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>indices <span class="hl opt">(</span><span class="hl kwa">calc-cell-indices</span> piece cell shift-table<span class="hl opt">)]</span>
                  <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(</span><span class="hl kwa">and</span> <span class="hl opt">(</span><span class="hl kwa">cells-fit-on-board</span> piece indices oob-table<span class="hl opt">)</span>
                             <span class="hl opt">(</span><span class="hl kwa">not</span> <span class="hl opt">(</span><span class="hl kwa">one-piece-has-island</span> indices shift-table
                                                        oob-table<span class="hl opt">)))</span>
                    <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>minimum <span class="hl opt">(</span><span class="hl kwa">apply</span> min indices<span class="hl opt">)</span>
                          <span class="hl opt">[</span>piece-mask0 piece-mask1<span class="hl opt">] (</span><span class="hl kwa">bitmask-from-indices</span>
                                                     indices<span class="hl opt">)</span>
                          next-index <span class="hl opt">(</span><span class="hl kwa">long</span> <span class="hl opt">(</span><span class="hl kwa">first-empty-cell-after</span> minimum
                                                                   indices<span class="hl opt">))]</span>

                      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^longs good-placement <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl num">3</span><span class="hl opt">)</span>
                            ^objects piece-arr <span class="hl opt">(</span><span class="hl kwa">aget</span> tbl p<span class="hl opt">)]</span>
                        <span class="hl opt">(</span><span class="hl kwa">aset</span> good-placement <span class="hl num">0</span> <span class="hl opt">(</span><span class="hl kwa">long</span> piece-mask0<span class="hl opt">))</span>
                        <span class="hl opt">(</span><span class="hl kwa">aset</span> good-placement <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">long</span> piece-mask1<span class="hl opt">))</span>
                        <span class="hl opt">(</span><span class="hl kwa">aset</span> good-placement <span class="hl num">2</span> next-index<span class="hl opt">)</span>
                        <span class="hl slc">;; Put it in the table</span>
                        <span class="hl opt">(</span><span class="hl kwa">aset</span> piece-arr minimum
                              <span class="hl opt">(</span><span class="hl kwa">conj</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> piece-arr minimum<span class="hl opt">)</span> good-placement<span class="hl opt">))</span>
                        <span class="hl opt">)))))</span>
              <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> rot<span class="hl opt">) (</span><span class="hl kwa">rotate-piece</span> piece<span class="hl opt">)))))))</span>
    <span class="hl slc">;; Make all transient vectors into Java object arrays</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>piece-num npieces<span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^objects piece-arr <span class="hl opt">(</span><span class="hl kwa">aget</span> tbl piece-num<span class="hl opt">)]</span>
        <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>cell <span class="hl num">50</span><span class="hl opt">]</span>
          <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>cur-vec <span class="hl opt">(</span><span class="hl kwa">persistent</span><span class="hl opt">! (</span><span class="hl kwa">aget</span> piece-arr cell<span class="hl opt">))]</span>
            <span class="hl opt">(</span><span class="hl kwa">aset</span> piece-arr cell <span class="hl opt">(</span><span class="hl kwa">object-array</span> cur-vec<span class="hl opt">))))))</span>
    tbl<span class="hl opt">))</span>



<span class="hl slc">;; first-empty-index-aux assumptions: idx is in the range [0,24].</span>
<span class="hl slc">;; half-board is an integer that has bits 25 and higher equal to 0, so</span>
<span class="hl slc">;; the loop is guaranteed to terminate, and the return value will be</span>
<span class="hl slc">;; in the range [0,25].</span>

<span class="hl opt">(</span><span class="hl kwa">defmacro</span> first-empty-index-aux <span class="hl opt">[</span>idx half-board<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>i<span class="hl opt">#</span> ~idx
          hb<span class="hl opt"># (</span><span class="hl kwa">bit-shift-right</span> ~half-board ~idx<span class="hl opt">)]</span>
     <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> hb<span class="hl opt">#</span> <span class="hl num">1</span><span class="hl opt">))</span>
       i<span class="hl opt">#</span>
       <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> i<span class="hl opt">#) (</span><span class="hl kwa">bit-shift-right</span> hb<span class="hl opt">#</span> <span class="hl num">1</span><span class="hl opt">)))))</span>


<span class="hl opt">(</span><span class="hl kwa">defmacro</span> first-empty-index <span class="hl opt">[</span>idx board0 board1<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;</span> ~idx <span class="hl num">25</span><span class="hl opt">)</span>
     <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>i<span class="hl opt"># (</span><span class="hl kwa">first-empty-index-aux</span> ~idx ~board0<span class="hl opt">)]</span>
       <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(==</span> i<span class="hl opt">#</span> <span class="hl num">25</span><span class="hl opt">)</span>
         <span class="hl opt">(+</span> <span class="hl num">25</span> <span class="hl opt">(</span><span class="hl kwa">first-empty-index-aux</span> <span class="hl num">0</span> ~board1<span class="hl opt">))</span>
         i<span class="hl opt">#))</span>
     <span class="hl opt">(+</span> <span class="hl num">25</span> <span class="hl opt">(</span><span class="hl kwa">first-empty-index-aux</span> <span class="hl opt">(</span><span class="hl kwa">-</span> ~idx <span class="hl num">25</span><span class="hl opt">)</span> ~board1<span class="hl opt">))))</span>


<span class="hl slc">;; Note: board-empty-region-sizes! runs faster if there are fewer</span>
<span class="hl slc">;; empty cells to fill.  So fill as much of the board as we can before</span>
<span class="hl slc">;; putting in the 3 partially filled rows.  There must be at least one</span>
<span class="hl slc">;; completely empty row at the bottom in order to correctly determine</span>
<span class="hl slc">;; whether these 3 rows are a bad triple.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> create-triples <span class="hl opt">[</span>shift-table oob-table<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>bad-even-triples <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl opt">(/ (</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1 15</span><span class="hl opt">)</span> <span class="hl num">32</span><span class="hl opt">))</span>
        bad-odd-triples <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl opt">(/ (</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1 15</span><span class="hl opt">)</span> <span class="hl num">32</span><span class="hl opt">))</span>
        temp-arr <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl num">50</span><span class="hl opt">)]</span>
    <span class="hl slc">;; Fill rows 0..5 completely.</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">30</span><span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">aset</span> temp-arr i <span class="hl num">1</span><span class="hl opt">))</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>row6 <span class="hl num">32</span><span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>row7 <span class="hl num">32</span><span class="hl opt">]</span>
        <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>row8 <span class="hl num">32</span><span class="hl opt">]</span>
          <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>board <span class="hl opt">(</span><span class="hl kwa">bit-or</span> <span class="hl opt">(</span><span class="hl kwa">bit-or</span> row6 <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> row7 <span class="hl num">5</span><span class="hl opt">))</span>
                              <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> row8 <span class="hl num">10</span><span class="hl opt">))]</span>
            <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">15</span><span class="hl opt">]</span>
              <span class="hl opt">(</span><span class="hl kwa">aset</span> temp-arr <span class="hl opt">(+</span> <span class="hl num">30</span> i<span class="hl opt">)</span>
                    <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> board i<span class="hl opt">))))</span>
            <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">5</span><span class="hl opt">]</span>   <span class="hl slc">;; Row 9 is completely empty to start with</span>
              <span class="hl opt">(</span><span class="hl kwa">aset</span> temp-arr <span class="hl opt">(+</span> <span class="hl num">45</span> i<span class="hl opt">)</span> <span class="hl num">0</span><span class="hl opt">))</span>
            <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>empty-region-sizes <span class="hl opt">(</span><span class="hl kwa">board-empty-region-sizes</span><span class="hl opt">!</span>
                                      temp-arr shift-table oob-table<span class="hl opt">)</span>
                  <span class="hl slc">;; Note that we assume board-empty-region-sizes!</span>
                  <span class="hl slc">;; returns a sequence, where the first element is</span>
                  <span class="hl slc">;; the size of the empty region that includes the</span>
                  <span class="hl slc">;; last cell, number 49.  Thus we can eliminate the</span>
                  <span class="hl slc">;; number of empty cells in that region simply by</span>
                  <span class="hl slc">;; removing the first element.</span>
                  empty-sizes-except-bottom <span class="hl opt">(</span><span class="hl kwa">rest</span> empty-region-sizes<span class="hl opt">)</span>
                  j <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> board <span class="hl num">5</span><span class="hl opt">)</span>
                  i <span class="hl opt">(</span><span class="hl kwa">bit-and</span> board <span class="hl opt">(</span><span class="hl kwa">int</span> <span class="hl num">0x1F</span><span class="hl opt">))]</span>
              <span class="hl opt">(</span><span class="hl kwa">when-not</span> <span class="hl opt">(</span><span class="hl kwa">every</span>? <span class="hl opt">#(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">rem</span> % <span class="hl num">5</span><span class="hl opt">))</span> empty-sizes-except-bottom<span class="hl opt">)</span>
                <span class="hl slc">;; then it is possible for pieces to fill the empty</span>
                <span class="hl slc">;; regions</span>
                <span class="hl opt">(</span><span class="hl kwa">aset</span> bad-even-triples j
                      <span class="hl opt">(</span><span class="hl kwa">bit-or</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> bad-even-triples j<span class="hl opt">)</span>
                              <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1</span> i<span class="hl opt">)))))))))</span>
    <span class="hl slc">;; Fill rows 0..4 completely.</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">25</span><span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">aset</span> temp-arr i <span class="hl num">1</span><span class="hl opt">))</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>row5 <span class="hl num">32</span><span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>row6 <span class="hl num">32</span><span class="hl opt">]</span>
        <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>row7 <span class="hl num">32</span><span class="hl opt">]</span>
          <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>board-rows-1-3 <span class="hl opt">(</span><span class="hl kwa">bit-or</span> <span class="hl opt">(</span><span class="hl kwa">bit-or</span> row5 <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> row6 <span class="hl num">5</span><span class="hl opt">))</span>
                                       <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> row7 <span class="hl num">10</span><span class="hl opt">))]</span>
            <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">15</span><span class="hl opt">]</span>
              <span class="hl opt">(</span><span class="hl kwa">aset</span> temp-arr <span class="hl opt">(+</span> <span class="hl num">25</span> i<span class="hl opt">)</span>
                    <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> board-rows-1-3 i<span class="hl opt">))))</span>
            <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl num">10</span><span class="hl opt">]</span>  <span class="hl slc">;; Rows 8 and 9 are completely empty to start with</span>
              <span class="hl opt">(</span><span class="hl kwa">aset</span> temp-arr <span class="hl opt">(+</span> <span class="hl num">40</span> i<span class="hl opt">)</span> <span class="hl num">0</span><span class="hl opt">))</span>
            <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>empty-region-sizes <span class="hl opt">(</span><span class="hl kwa">board-empty-region-sizes</span><span class="hl opt">!</span>
                                      temp-arr shift-table oob-table<span class="hl opt">)</span>
                  empty-sizes-except-bottom <span class="hl opt">(</span><span class="hl kwa">rest</span> empty-region-sizes<span class="hl opt">)</span>
                  j <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> board-rows-1-3 <span class="hl num">5</span><span class="hl opt">)</span>
                  i <span class="hl opt">(</span><span class="hl kwa">bit-and</span> board-rows-1-3 <span class="hl num">0x1F</span><span class="hl opt">)]</span>
              <span class="hl opt">(</span><span class="hl kwa">when-not</span> <span class="hl opt">(</span><span class="hl kwa">every</span>? <span class="hl opt">#(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">rem</span> % <span class="hl num">5</span><span class="hl opt">))</span> empty-sizes-except-bottom<span class="hl opt">)</span>
                <span class="hl opt">(</span><span class="hl kwa">aset</span> bad-odd-triples j
                      <span class="hl opt">(</span><span class="hl kwa">bit-or</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> bad-odd-triples j<span class="hl opt">)</span>
                              <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1</span> i<span class="hl opt">)))</span>
                <span class="hl opt">))))))</span>
    <span class="hl opt">[</span>bad-even-triples bad-odd-triples<span class="hl opt">]))</span>


<span class="hl opt">(</span><span class="hl kwa">def</span> num-solutions <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl num">1</span><span class="hl opt">))</span>
<span class="hl opt">(</span><span class="hl kwa">def</span> all-solutions <span class="hl opt">(</span><span class="hl kwa">object-array</span> <span class="hl num">2200</span><span class="hl opt">))</span>

<span class="hl slc">;; See comments above +piece-num-to-do-only-3-rotations+.  Each</span>
<span class="hl slc">;; solution is thus recorded twice.  Reversing the solution has the</span>
<span class="hl slc">;; effect of rotating it 180 degrees.</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> record-solution<span class="hl opt">! [</span>^longs soln<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^longs num-solutions num-solutions
        ^objects all-solutions all-solutions
        n <span class="hl opt">(</span><span class="hl kwa">aget</span> num-solutions <span class="hl num">0</span><span class="hl opt">)</span>
        ^longs rotated-soln <span class="hl opt">(</span><span class="hl kwa">aclone</span> soln<span class="hl opt">)</span>
        len <span class="hl opt">(</span><span class="hl kwa">alength</span> soln<span class="hl opt">)</span>
        len-1 <span class="hl opt">(</span><span class="hl kwa">dec</span> len<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">aset</span> all-solutions n soln<span class="hl opt">)</span>
    <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl opt">(/</span> len <span class="hl num">2</span><span class="hl opt">)]</span>
      <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>tmp <span class="hl opt">(</span><span class="hl kwa">aget</span> rotated-soln i<span class="hl opt">)</span>
            other-idx <span class="hl opt">(</span><span class="hl kwa">-</span> len-1 i<span class="hl opt">)]</span>
        <span class="hl opt">(</span><span class="hl kwa">aset</span> rotated-soln i <span class="hl opt">(</span><span class="hl kwa">aget</span> rotated-soln other-idx<span class="hl opt">))</span>
        <span class="hl opt">(</span><span class="hl kwa">aset</span> rotated-soln other-idx tmp<span class="hl opt">)))</span>
    <span class="hl opt">(</span><span class="hl kwa">aset</span> all-solutions <span class="hl opt">(</span><span class="hl kwa">inc</span> n<span class="hl opt">)</span> rotated-soln<span class="hl opt">)</span>
    <span class="hl opt">(</span><span class="hl kwa">aset</span> num-solutions <span class="hl num">0</span> <span class="hl opt">(+</span> n <span class="hl num">2</span><span class="hl opt">))))</span>


<span class="hl slc">;; Assume all args have been type-hinted to int in the environment</span>
<span class="hl slc">;; where the macro board-has-no-islands is called.</span>

<span class="hl opt">(</span><span class="hl kwa">defmacro</span> board-has-no-islands <span class="hl opt">[</span>board0 board1 index
                                ^longs bad-even-triples
                                ^longs bad-odd-triples<span class="hl opt">]</span>
  <span class="hl opt">`(</span><span class="hl kwa">if</span> <span class="hl opt">(&gt;=</span> ~index <span class="hl num">40</span><span class="hl opt">)</span>
     true
     <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>row-num<span class="hl opt"># (</span><span class="hl kwa">long</span> <span class="hl opt">(/</span> ~index <span class="hl num">5</span><span class="hl opt">))</span>
           current-3-rows<span class="hl opt">#</span>
           <span class="hl opt">(</span><span class="hl kwa">case</span> row-num<span class="hl opt">#</span>
                 <span class="hl num">0</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x7FFF</span> ~board0<span class="hl opt">)</span>
                 <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x7FFF</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> ~board0 <span class="hl num">5</span><span class="hl opt">))</span>
                 <span class="hl num">2</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x7FFF</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> ~board0 <span class="hl num">10</span><span class="hl opt">))</span>
                 <span class="hl num">3</span> <span class="hl opt">(</span><span class="hl kwa">bit-or</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> ~board0 <span class="hl num">15</span><span class="hl opt">)</span>
                           <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x1F</span> ~board1<span class="hl opt">)</span>
                                           <span class="hl num">10</span><span class="hl opt">))</span>
                 <span class="hl num">4</span> <span class="hl opt">(</span><span class="hl kwa">bit-or</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> ~board0 <span class="hl num">20</span><span class="hl opt">)</span>
                           <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x3FF</span> ~board1<span class="hl opt">)</span> <span class="hl num">5</span><span class="hl opt">))</span>
                 <span class="hl num">5</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x7FFF</span> ~board1<span class="hl opt">)</span>
                 <span class="hl num">6</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x7FFF</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> ~board1 <span class="hl num">5</span><span class="hl opt">))</span>
                 <span class="hl num">7</span> <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">0x7FFF</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> ~board1 <span class="hl num">10</span><span class="hl opt">)))</span>
           int-num<span class="hl opt"># (</span><span class="hl kwa">bit-shift-right</span> current-3-rows<span class="hl opt">#</span> <span class="hl num">5</span><span class="hl opt">)</span>
           bit-num<span class="hl opt"># (</span><span class="hl kwa">bit-and</span> current-3-rows<span class="hl opt">#</span> <span class="hl num">0x1F</span><span class="hl opt">)</span>
           even-row<span class="hl opt"># (</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> row-num<span class="hl opt">#</span> <span class="hl num">1</span><span class="hl opt">))]</span>
       <span class="hl opt">(</span><span class="hl kwa">if</span> even-row<span class="hl opt">#</span>
         <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> ~bad-even-triples int-num<span class="hl opt">#)</span>
                                            bit-num<span class="hl opt">#)))</span>
         <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> <span class="hl num">1</span> <span class="hl opt">(</span><span class="hl kwa">bit-shift-right</span> <span class="hl opt">(</span><span class="hl kwa">aget</span> ~bad-odd-triples int-num<span class="hl opt">#)</span>
                                            bit-num<span class="hl opt">#)))))))</span>


<span class="hl slc">;; Arguments to solve-helper:</span>

<span class="hl slc">;; depth is 0 on the first call, and is 1 more for each level of</span>
<span class="hl slc">;; nested recursive call.  It is equal to the number of pieces placed</span>
<span class="hl slc">;; on the board in the partial solution so far.</span>

<span class="hl slc">;; board is a pair of 32-bit longs representing which board cells are</span>
<span class="hl slc">;; occupied (bit value 1) or empty (bit value 0), based upon the</span>
<span class="hl slc">;; pieces placed so far.  Bits positions 0..24 of board0 represent</span>
<span class="hl slc">;; board indices 0..24, and bit positions 0..24 of board1 represent</span>
<span class="hl slc">;; board indices 25..49.</span>

<span class="hl slc">;; cell is the board index in [0,49] that should be checked first to</span>
<span class="hl slc">;; see if it is empty.</span>

<span class="hl slc">;; placed-piece-bit-vec is an int where its 10 least significant bits</span>
<span class="hl slc">;; represent the set of the piece numbers, each in the range [0,9],</span>
<span class="hl slc">;; that have been placed so far in the current configuration.  If bit</span>
<span class="hl slc">;; i is 1, i in [0,9], then piece i has already been placed.</span>

<span class="hl slc">;; piece-num-arr is an array of the piece-nums placed so far, in the</span>
<span class="hl slc">;; order they were placed, i.e. depth order.  (aget piece-num-arr 0)</span>
<span class="hl slc">;; was placed at depth 0, etc.  (named sol_nums in GCC program)</span>

<span class="hl slc">;; mask-arr is an array of the bitmasks of the pieces placed so far,</span>
<span class="hl slc">;; in the order they were placed.  (named sol_masks in GCC program)</span>

<span class="hl opt">(</span><span class="hl kwa">defn</span> solve<span class="hl opt">! [</span>^objects tbl ^longs bad-even-triples ^longs bad-odd-triples<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">letfn</span>
      <span class="hl opt">[(</span><span class="hl kwa">solve-helper</span> <span class="hl opt">[</span>depth board0 board1 orig-cell placed-piece-bit-vec
                      ^longs piece-num-arr ^longs mask-arr0 ^longs mask-arr1<span class="hl opt">]</span>
         <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>depth depth
               board0 board0
               board1 board1
               orig-cell orig-cell
               cell <span class="hl opt">(</span><span class="hl kwa">first-empty-index</span> orig-cell board0 board1<span class="hl opt">)</span>
               placed-piece-bit-vec-int placed-piece-bit-vec<span class="hl opt">]</span>
           <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>piece-num <span class="hl num">0</span>
                  piece-num-mask <span class="hl num">1</span><span class="hl opt">]</span>
             <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(&lt;</span> piece-num <span class="hl num">10</span><span class="hl opt">)</span>
               <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> placed-piece-bit-vec-int piece-num-mask<span class="hl opt">))</span>
                 <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^objects piece-arr <span class="hl opt">(</span><span class="hl kwa">aget</span> tbl piece-num<span class="hl opt">)</span>
                       ^objects placements <span class="hl opt">(</span><span class="hl kwa">aget</span> piece-arr cell<span class="hl opt">)]</span>
                   <span class="hl opt">(</span><span class="hl kwa">dotimes</span> <span class="hl opt">[</span>i <span class="hl opt">(</span><span class="hl kwa">alength</span> placements<span class="hl opt">)]</span>
                     <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^longs placement <span class="hl opt">(</span><span class="hl kwa">aget</span> placements i<span class="hl opt">)</span>
                           piece-mask0 <span class="hl opt">(</span><span class="hl kwa">aget</span> placement <span class="hl num">0</span><span class="hl opt">)</span>
                           piece-mask1 <span class="hl opt">(</span><span class="hl kwa">aget</span> placement <span class="hl num">1</span><span class="hl opt">)</span>
                           next-index <span class="hl opt">(</span><span class="hl kwa">aget</span> placement <span class="hl num">2</span><span class="hl opt">)</span>
                           piece-num-int piece-num<span class="hl opt">]</span>
                       <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(</span><span class="hl kwa">and</span> <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> board0 piece-mask0<span class="hl opt">))</span>
                                  <span class="hl opt">(</span><span class="hl kwa">zero</span>? <span class="hl opt">(</span><span class="hl kwa">bit-and</span> board1 piece-mask1<span class="hl opt">)))</span>
                         <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(==</span> depth <span class="hl num">9</span><span class="hl opt">)</span>
                           <span class="hl slc">;; Solution found!</span>
                           <span class="hl opt">(</span><span class="hl kwa">do</span>
                             <span class="hl opt">(</span><span class="hl kwa">aset</span> piece-num-arr depth piece-num-int<span class="hl opt">)</span>
                             <span class="hl opt">(</span><span class="hl kwa">aset</span> mask-arr0 depth piece-mask0<span class="hl opt">)</span>
                             <span class="hl opt">(</span><span class="hl kwa">aset</span> mask-arr1 depth piece-mask1<span class="hl opt">)</span>
                             <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>sol1 <span class="hl opt">(</span><span class="hl kwa">encode-solution</span> piece-num-arr
                                                         mask-arr0 mask-arr1<span class="hl opt">)]</span>
                               <span class="hl opt">(</span><span class="hl kwa">record-solution</span><span class="hl opt">!</span> sol1<span class="hl opt">)))</span>
                           <span class="hl slc">;; else</span>
                           <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>next-board0 <span class="hl opt">(</span><span class="hl kwa">bit-or</span> board0 piece-mask0<span class="hl opt">)</span>
                                 next-board1 <span class="hl opt">(</span><span class="hl kwa">bit-or</span> board1 piece-mask1<span class="hl opt">)]</span>
                             <span class="hl opt">(</span><span class="hl kwa">when</span> <span class="hl opt">(</span><span class="hl kwa">board-has-no-islands</span> next-board0 next-board1
                                                         next-index
                                                         bad-even-triples
                                                         bad-odd-triples<span class="hl opt">)</span>
                               <span class="hl opt">(</span><span class="hl kwa">aset</span> piece-num-arr depth piece-num-int<span class="hl opt">)</span>
                               <span class="hl opt">(</span><span class="hl kwa">aset</span> mask-arr0 depth piece-mask0<span class="hl opt">)</span>
                               <span class="hl opt">(</span><span class="hl kwa">aset</span> mask-arr1 depth piece-mask1<span class="hl opt">)</span>
                               <span class="hl opt">(</span><span class="hl kwa">solve-helper</span>
                                <span class="hl opt">(</span><span class="hl kwa">inc</span> depth<span class="hl opt">)</span>
                                next-board0 next-board1
                                next-index
                                <span class="hl opt">(</span><span class="hl kwa">bit-or</span> placed-piece-bit-vec-int
                                        <span class="hl opt">(</span><span class="hl kwa">bit-shift-left</span> <span class="hl num">1</span> piece-num-int<span class="hl opt">))</span>
                                piece-num-arr
                                mask-arr0 mask-arr1<span class="hl opt">)))))))))</span>
               <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> piece-num<span class="hl opt">) (</span><span class="hl kwa">bit-shift-left</span> piece-num-mask <span class="hl num">1</span><span class="hl opt">))</span>
               <span class="hl opt">))))]</span>
    <span class="hl opt">(</span><span class="hl kwa">solve-helper</span> <span class="hl num">0 0 0 0 0</span> <span class="hl opt">(</span><span class="hl kwa">long-array</span> <span class="hl num">10</span><span class="hl opt">) (</span><span class="hl kwa">long-array</span> <span class="hl num">10</span><span class="hl opt">) (</span><span class="hl kwa">long-array</span> <span class="hl num">10</span><span class="hl opt">))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> compare-long-arrays <span class="hl opt">[</span>^longs a ^longs b<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>len <span class="hl opt">(</span><span class="hl kwa">min</span> <span class="hl opt">(</span><span class="hl kwa">alength</span> a<span class="hl opt">) (</span><span class="hl kwa">alength</span> b<span class="hl opt">))]</span>
    <span class="hl opt">(</span><span class="hl kwa">loop</span> <span class="hl opt">[</span>i <span class="hl num">0</span><span class="hl opt">]</span>
      <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(&lt;</span> i len<span class="hl opt">)</span>
        <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>elem-a <span class="hl opt">(</span><span class="hl kwa">aget</span> a i<span class="hl opt">)</span>
              elem-b <span class="hl opt">(</span><span class="hl kwa">aget</span> b i<span class="hl opt">)]</span>
          <span class="hl opt">(</span><span class="hl kwa">if</span> <span class="hl opt">(==</span> elem-a elem-b<span class="hl opt">)</span>
            <span class="hl opt">(</span><span class="hl kwa">recur</span> <span class="hl opt">(</span><span class="hl kwa">inc</span> i<span class="hl opt">))</span>
            <span class="hl opt">(</span><span class="hl kwa">-</span> elem-a elem-b<span class="hl opt">)))</span>
        <span class="hl num">0</span><span class="hl opt">))))</span>


<span class="hl opt">(</span><span class="hl kwa">defn</span> -main <span class="hl opt">[&amp;</span> args<span class="hl opt">]</span>
  <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>shift-table <span class="hl opt">(</span><span class="hl kwa">make-shift-table</span><span class="hl opt">)</span>
        oob-table <span class="hl opt">(</span><span class="hl kwa">make-oob-table</span><span class="hl opt">)</span>
        tbl <span class="hl opt">(</span><span class="hl kwa">calc-pieces</span> piece-defs shift-table oob-table<span class="hl opt">)</span>
        <span class="hl opt">[</span>bad-even-triples bad-odd-triples<span class="hl opt">] (</span><span class="hl kwa">create-triples</span> shift-table
                                                           oob-table<span class="hl opt">)]</span>
    <span class="hl opt">(</span><span class="hl kwa">solve</span><span class="hl opt">!</span> tbl bad-even-triples bad-odd-triples<span class="hl opt">)</span>
    <span class="hl opt">(</span><span class="hl kwa">let</span> <span class="hl opt">[</span>^longs num-solutions num-solutions
          n <span class="hl opt">(</span><span class="hl kwa">aget</span> num-solutions <span class="hl num">0</span><span class="hl opt">)</span>
          sorted-solns <span class="hl opt">(</span><span class="hl kwa">sort</span> compare-long-arrays <span class="hl opt">(</span><span class="hl kwa">take</span> n <span class="hl opt">(</span><span class="hl kwa">seq</span> all-solutions<span class="hl opt">)))]</span>
      <span class="hl opt">(</span><span class="hl kwa">println</span> <span class="hl opt">(</span><span class="hl kwa">format</span> <span class="hl str">&quot;%d solutions found&quot;</span> n<span class="hl opt">))</span>
      <span class="hl opt">(</span><span class="hl kwa">print-board</span> <span class="hl opt">(</span><span class="hl kwa">first</span> sorted-solns<span class="hl opt">))</span>
      <span class="hl opt">(</span><span class="hl kwa">println</span><span class="hl opt">)</span>
      <span class="hl opt">(</span><span class="hl kwa">print-board</span> <span class="hl opt">(</span><span class="hl kwa">nth</span> sorted-solns <span class="hl opt">(</span><span class="hl kwa">dec</span> n<span class="hl opt">)))</span>
      <span class="hl opt">(</span><span class="hl kwa">println</span><span class="hl opt">)</span>
      <span class="hl opt">(</span><span class="hl kwa">println</span><span class="hl opt">))))</span>  <span class="hl slc">; Just to match the output of the other programs exactly</span>
