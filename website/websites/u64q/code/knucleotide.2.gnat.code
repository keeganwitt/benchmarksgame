<span class="hl slc">--  The Computer Language Benchmarks Game</span>
<span class="hl slc">--  http://benchmarksgame.alioth.debian.org/</span>
<span class="hl slc">--</span>
<span class="hl slc">--  Contributed by Martin Krischik</span>
<span class="hl slc">--  Modified by Georg Bauhaus and Jonathan Parker</span>

<span class="hl kwa">pragma</span> Restrictions <span class="hl opt">(</span>No_Abort_Statements<span class="hl opt">);</span>
<span class="hl kwa">pragma</span> Restrictions <span class="hl opt">(</span>Max_Asynchronous_Select_Nesting <span class="hl opt">=&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>

<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Characters<span class="hl opt">.</span>Latin_1<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Integer_Text_IO<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Float_Text_IO<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Text_IO<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Exceptions<span class="hl opt">;</span>

<span class="hl kwa">with</span> String_Fragments<span class="hl opt">;</span>
<span class="hl kwa">with</span> Data_Input<span class="hl opt">;</span>
<span class="hl kwa">with</span> GNAT<span class="hl opt">.</span>Heap_Sort_G<span class="hl opt">;</span>
<span class="hl kwa">with</span> GNAT<span class="hl opt">.</span>HTable<span class="hl opt">;</span>

<span class="hl kwa">procedure</span> KNucleotide <span class="hl kwa">is</span>

   <span class="hl kwa">subtype</span> Fragment_Lengths <span class="hl kwa">is</span> <span class="hl kwb">Integer</span> <span class="hl kwa">range</span> <span class="hl num">1</span> <span class="hl opt">..</span> <span class="hl num">18</span><span class="hl opt">;</span>

   <span class="hl slc">--  Data read as single String:</span>

   Buffer <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">String</span> <span class="hl opt">:=</span> Data_Input<span class="hl opt">.</span>Read<span class="hl opt">;</span>

   <span class="hl slc">--  Calculate and write data - either a percentage for all fragments found</span>
   <span class="hl slc">--  or - when Nucleotide_Fragment is given - the count for that fragment.</span>

   <span class="hl kwa">generic</span>
      <span class="hl kwa">with package</span> Fragments <span class="hl kwa">is new</span> String_Fragments<span class="hl opt">(&lt;&gt;);</span>
   <span class="hl kwa">package</span> Work <span class="hl kwa">is</span>

      <span class="hl kwa">procedure</span> Write
        <span class="hl opt">(</span>Nucleotide_Length   <span class="hl opt">:</span> <span class="hl kwa">in</span> Fragment_Lengths<span class="hl opt">;</span>
         Nucleotide_Fragment <span class="hl opt">:</span> <span class="hl kwa">in</span> Fragments<span class="hl opt">.</span>Fragment <span class="hl opt">:=</span> Fragments<span class="hl opt">.</span>Null_Fragment<span class="hl opt">);</span>

      <span class="hl kwa">task</span> Writer <span class="hl kwa">is</span>
         <span class="hl slc">--</span>
         <span class="hl slc">--  Performs `Write` calls</span>
         <span class="hl slc">--</span>
         <span class="hl kwa">pragma</span> Storage_Size <span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">**</span><span class="hl num">24</span><span class="hl opt">);</span>

         <span class="hl kwa">entry</span> Set <span class="hl opt">(</span>Nucleotide_Length   <span class="hl opt">:</span> <span class="hl kwa">in</span> Fragment_Lengths<span class="hl opt">;</span>
                    Nucleotide_Fragment <span class="hl opt">:</span> <span class="hl kwa">in</span> Fragments<span class="hl opt">.</span>Fragment <span class="hl opt">:=</span> Fragments<span class="hl opt">.</span>Null_Fragment<span class="hl opt">);</span>
      <span class="hl kwa">end</span> Writer<span class="hl opt">;</span>

   <span class="hl kwa">end</span> Work<span class="hl opt">;</span>


   <span class="hl kwa">type</span> Order <span class="hl kwa">is array</span> <span class="hl opt">(</span>Fragment_Lengths<span class="hl opt">)</span> <span class="hl kwa">of</span> <span class="hl kwb">Boolean</span><span class="hl opt">;</span>

   <span class="hl kwa">protected</span> Printer <span class="hl kwa">is</span>
      <span class="hl slc">--</span>
      <span class="hl slc">--  Serializes access to output</span>
      <span class="hl slc">--</span>
      <span class="hl kwa">entry</span> Seize <span class="hl opt">(</span>Fragment_Lengths<span class="hl opt">);</span>
      <span class="hl kwa">procedure</span> Release <span class="hl opt">(</span>L <span class="hl opt">:</span> Fragment_Lengths<span class="hl opt">);</span>

   <span class="hl kwa">private</span>
      Done <span class="hl opt">:</span> Order <span class="hl opt">:=</span>
        <span class="hl opt">(</span><span class="hl num">1</span> | <span class="hl num">2</span> | <span class="hl num">3</span> | <span class="hl num">4</span> | <span class="hl num">6</span> | <span class="hl num">12</span> | <span class="hl num">18</span> <span class="hl opt">=&gt;</span> <span class="hl kwd">False</span><span class="hl opt">,</span>
         <span class="hl kwa">others</span> <span class="hl opt">=&gt;</span> <span class="hl kwd">True</span><span class="hl opt">);</span>
   <span class="hl kwa">end</span> Printer<span class="hl opt">;</span>

   <span class="hl kwa">protected body</span> Printer <span class="hl kwa">is</span>

      <span class="hl slc">--  Use families' entry indexes to find that output of preceding</span>
      <span class="hl slc">--  `Write`s has already been produced thus ordering the tasks's results.</span>

      <span class="hl kwa">entry</span> Seize <span class="hl opt">(</span><span class="hl kwa">for</span> L <span class="hl kwa">in</span> Fragment_Lengths<span class="hl opt">)</span>
      <span class="hl kwa">when</span> Done <span class="hl opt">(</span><span class="hl num">1</span> <span class="hl opt">..</span> Fragment_Lengths<span class="hl kwd">'Pred</span><span class="hl opt">(</span>L<span class="hl opt">)) = (</span><span class="hl num">1</span> <span class="hl opt">..</span> Fragment_Lengths<span class="hl kwd">'Pred</span><span class="hl opt">(</span>L<span class="hl opt">) =&gt;</span> <span class="hl kwd">True</span><span class="hl opt">)</span> <span class="hl kwa">is</span>
      <span class="hl kwa">begin</span>
         <span class="hl kwa">null</span><span class="hl opt">;</span>
      <span class="hl kwa">end</span> Seize<span class="hl opt">;</span>

      <span class="hl kwa">procedure</span> Release <span class="hl opt">(</span>L <span class="hl opt">:</span> Fragment_Lengths<span class="hl opt">)</span> <span class="hl kwa">is</span>
      <span class="hl kwa">begin</span>
         Done <span class="hl opt">(</span>L<span class="hl opt">) :=</span> <span class="hl kwd">True</span><span class="hl opt">;</span>
      <span class="hl kwa">end</span> Release<span class="hl opt">;</span>

   <span class="hl kwa">end</span> Printer<span class="hl opt">;</span>

   <span class="hl kwa">package body</span> Work <span class="hl kwa">is</span>

      <span class="hl slc">---------------------</span>
      <span class="hl slc">-- procedure Write --</span>
      <span class="hl slc">---------------------</span>

      <span class="hl slc">--  Procedure KNucleotide's tasks call Write in order to calculate and</span>
      <span class="hl slc">--  write data - either a percentage for all fragments found or - when</span>
      <span class="hl slc">--  Nucleotide_Fragment is given - the count for that fragment.</span>
      <span class="hl slc">--</span>
      <span class="hl kwa">procedure</span> Write
        <span class="hl opt">(</span>Nucleotide_Length   <span class="hl opt">:</span> <span class="hl kwa">in</span> Fragment_Lengths<span class="hl opt">;</span>
         Nucleotide_Fragment <span class="hl opt">:</span> <span class="hl kwa">in</span> Fragments<span class="hl opt">.</span>Fragment <span class="hl opt">:=</span> Fragments<span class="hl opt">.</span>Null_Fragment<span class="hl opt">)</span>
      <span class="hl kwa">is</span>
         <span class="hl kwa">use</span> Fragments<span class="hl opt">;</span>

         <span class="hl slc">--  Package is an interface to GNAT's simple hash table: GNAT.HTable.</span>
         <span class="hl slc">--  The package calculates nucleotide Fragment_Lengths and keeps the</span>
         <span class="hl slc">--  result inside a hash table as requested by the shootout rules.</span>

         <span class="hl kwa">package</span> Calculator <span class="hl kwa">is</span>

            <span class="hl slc">--  Elements used to store inside hash table:</span>

            <span class="hl kwa">type</span> Element_Type <span class="hl kwa">is private</span><span class="hl opt">;</span>
            <span class="hl kwa">type</span> Element_Access <span class="hl kwa">is access</span> Element_Type<span class="hl opt">;</span>
            <span class="hl kwa">for</span> Element_Access<span class="hl kwd">'Storage_Size</span> <span class="hl kwa">use</span> <span class="hl num">16</span>#<span class="hl num">60</span>_00_01#<span class="hl opt">;</span>


<span class="hl slc">--  Calculate frequency of occurrence of the nucleotides:</span>

            <span class="hl kwa">procedure</span> Get_Frequencies <span class="hl opt">(</span>Length <span class="hl opt">:</span> Fragment_Lengths<span class="hl opt">);</span>

            <span class="hl slc">--  Get the count for the given nucleotide fragment:</span>

            <span class="hl kwa">function</span> Number_Counted <span class="hl opt">(</span>Nucleotide_Fragment <span class="hl opt">:</span> Fragment<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Natural</span><span class="hl opt">;</span>

            <span class="hl slc">--  Start to iterate over all elements of hash table:</span>

            <span class="hl kwa">function</span> Get_First <span class="hl kwa">return</span> Element_Access<span class="hl opt">;</span>

            <span class="hl slc">--  Continue itereation over the hash table:</span>

            <span class="hl kwa">function</span> Get_Next <span class="hl kwa">return</span> Element_Access<span class="hl opt">;</span>

            <span class="hl slc">--  Key and value when computed:</span>

            <span class="hl kwa">function</span> Count_Of <span class="hl opt">(</span>Element <span class="hl opt">:</span> <span class="hl kwa">not null</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Natural</span><span class="hl opt">;</span>
            <span class="hl kwa">function</span> Fragment_Of <span class="hl opt">(</span>Element <span class="hl opt">:</span> <span class="hl kwa">not null</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> Fragment<span class="hl opt">;</span>

            <span class="hl slc">--  Get total count over all elements - as well as the count of</span>
            <span class="hl slc">--  elements:</span>

            <span class="hl kwa">procedure</span> Get_Totals <span class="hl opt">(</span>Total <span class="hl opt">:</span> <span class="hl kwa">out</span> <span class="hl kwb">Natural</span><span class="hl opt">;</span> Count <span class="hl opt">:</span> <span class="hl kwa">out</span> <span class="hl kwb">Natural</span><span class="hl opt">);</span>

         <span class="hl kwa">private</span>
            <span class="hl kwa">pragma</span> Inline <span class="hl opt">(</span>Count_of<span class="hl opt">,</span> Fragment_Of<span class="hl opt">);</span>

            <span class="hl kwa">type</span> Element_Type <span class="hl kwa">is record</span>
               Count <span class="hl opt">:</span> <span class="hl kwb">Natural</span>        <span class="hl opt">:=</span> <span class="hl num">0</span><span class="hl opt">;</span>
               Key   <span class="hl opt">:</span> Fragment       <span class="hl opt">:=</span> Fragments<span class="hl opt">.</span>Null_Fragment<span class="hl opt">;</span>
               Next  <span class="hl opt">:</span> Element_Access <span class="hl opt">:=</span> <span class="hl kwa">null</span><span class="hl opt">;</span>
            <span class="hl kwa">end record</span><span class="hl opt">;</span>
         <span class="hl kwa">end</span> Calculator<span class="hl opt">;</span>

         <span class="hl kwa">package body</span> Calculator <span class="hl kwa">is</span>

            Log_Table_Size <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">Natural</span> <span class="hl opt">:=</span> <span class="hl kwb">Natural</span><span class="hl kwd">'Min</span> <span class="hl opt">(</span>Fragment<span class="hl kwd">'Last</span><span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">+</span><span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">17</span><span class="hl opt">);</span>
            Table_Size     <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">Natural</span> <span class="hl opt">:=</span> <span class="hl num">2</span> <span class="hl opt">**</span> Log_Table_Size<span class="hl opt">;</span>

            <span class="hl kwa">subtype</span> Hash_Type <span class="hl kwa">is</span> <span class="hl kwb">Natural</span> <span class="hl kwa">range</span> <span class="hl num">0</span> <span class="hl opt">..</span> Table_Size <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">;</span>

            <span class="hl kwa">function</span> Hash <span class="hl opt">(</span>Key <span class="hl opt">:</span> Fragment<span class="hl opt">)</span> <span class="hl kwa">return</span> Hash_Type<span class="hl opt">;</span>
            <span class="hl kwa">procedure</span> Set_Next <span class="hl opt">(</span>E <span class="hl opt">:</span> Element_Access<span class="hl opt">;</span> Next <span class="hl opt">:</span> Element_Access<span class="hl opt">);</span>
            <span class="hl kwa">function</span> Next <span class="hl opt">(</span>E <span class="hl opt">:</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> Element_Access<span class="hl opt">;</span>
            <span class="hl kwa">function</span> Get_Key <span class="hl opt">(</span>E <span class="hl opt">:</span> <span class="hl kwa">not null</span> Element_Access<span class="hl opt">)</span> <span class="hl kwa">return</span> Fragment<span class="hl opt">;</span>

            <span class="hl kwa">pragma</span> Inline <span class="hl opt">(</span>Hash<span class="hl opt">,</span> Set_Next<span class="hl opt">,</span> Next<span class="hl opt">,</span> Get_Key<span class="hl opt">);</span>

            <span class="hl kwa">package</span> Table <span class="hl kwa">is new</span> GNAT<span class="hl opt">.</span>HTable<span class="hl opt">.</span>Static_HTable
              <span class="hl opt">(</span>Header_Num <span class="hl opt">=&gt;</span> Hash_Type<span class="hl opt">,</span>
               Element    <span class="hl opt">=&gt;</span> Element_Type<span class="hl opt">,</span>
               Elmt_Ptr   <span class="hl opt">=&gt;</span> Element_Access<span class="hl opt">,</span>
               Null_Ptr   <span class="hl opt">=&gt;</span> <span class="hl kwa">null</span><span class="hl opt">,</span>
               Key        <span class="hl opt">=&gt;</span> Fragment<span class="hl opt">,</span>
               Hash       <span class="hl opt">=&gt;</span> Hash<span class="hl opt">,</span>
               Equal      <span class="hl opt">=&gt;</span> Fragments<span class="hl opt">.</span><span class="hl str">&quot;=&quot;</span><span class="hl opt">,</span>
               Set_Next   <span class="hl opt">=&gt;</span> Set_Next<span class="hl opt">,</span>
               Next       <span class="hl opt">=&gt;</span> Next<span class="hl opt">,</span>
               Get_Key    <span class="hl opt">=&gt;</span> Get_Key<span class="hl opt">);</span>


            <span class="hl kwa">function</span> Hash <span class="hl opt">(</span>Key <span class="hl opt">:</span> Fragment<span class="hl opt">)</span> <span class="hl kwa">return</span> Hash_Type <span class="hl kwa">is</span>
               <span class="hl kwa">pragma</span> Assert <span class="hl opt">(</span>Hash_Type<span class="hl kwd">'First</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">);</span>
               <span class="hl kwa">pragma</span> Assert <span class="hl opt">(</span>Hash_Type<span class="hl kwd">'Last</span>  <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">**</span>Log_Table_Size <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span>
               <span class="hl kwa">type</span> Uns_32 <span class="hl kwa">is mod</span> <span class="hl num">2</span><span class="hl opt">**</span><span class="hl num">32</span><span class="hl opt">;</span>
               H <span class="hl opt">:</span> Uns_32 <span class="hl opt">:=</span> <span class="hl kwb">Character</span><span class="hl kwd">'Pos</span> <span class="hl opt">(</span>Key <span class="hl opt">(</span>Key<span class="hl kwd">'First</span><span class="hl opt">));</span>
            <span class="hl kwa">begin</span>
               <span class="hl kwa">for</span> J <span class="hl kwa">in</span> Key<span class="hl kwd">'First</span> <span class="hl opt">+</span> <span class="hl num">1</span> <span class="hl opt">..</span> Key<span class="hl kwd">'Last</span> <span class="hl kwa">loop</span>
                  H <span class="hl opt">:=</span> <span class="hl kwb">Character</span><span class="hl kwd">'Pos</span> <span class="hl opt">(</span>Key <span class="hl opt">(</span>J<span class="hl opt">)) +</span> H <span class="hl opt">*</span> <span class="hl num">2</span><span class="hl opt">**</span><span class="hl num">3</span> <span class="hl opt">+</span> H<span class="hl opt">;</span>
               <span class="hl kwa">end loop</span><span class="hl opt">;</span>
               H <span class="hl opt">:= (</span>H <span class="hl opt">/</span> <span class="hl num">2</span><span class="hl opt">**</span>Log_Table_Size<span class="hl opt">)</span> <span class="hl kwa">xor</span> H<span class="hl opt">;</span>
               <span class="hl kwa">return</span> Hash_Type<span class="hl kwd">'Base</span> <span class="hl opt">(</span>H <span class="hl kwa">mod</span> <span class="hl num">2</span><span class="hl opt">**</span>Log_Table_Size<span class="hl opt">);</span>
            <span class="hl kwa">end</span> Hash<span class="hl opt">;</span>


            <span class="hl kwa">procedure</span> Get_Frequencies <span class="hl opt">(</span>Length <span class="hl opt">:</span> Fragment_Lengths<span class="hl opt">)</span> <span class="hl kwa">is</span>
            <span class="hl kwa">begin</span>
               <span class="hl kwa">for</span> I <span class="hl kwa">in</span>  <span class="hl num">1</span> <span class="hl opt">..</span> Buffer<span class="hl kwd">'Last</span> <span class="hl opt">-</span> Length <span class="hl opt">+</span> <span class="hl num">1</span> <span class="hl kwa">loop</span>
                  <span class="hl kwa">declare</span>
                     Key <span class="hl opt">:</span> <span class="hl kwb">String</span> <span class="hl kwa">renames</span> Buffer<span class="hl opt">(</span>I <span class="hl opt">..</span> I <span class="hl opt">+</span> Length <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span>
                     Element <span class="hl opt">:</span> <span class="hl kwa">constant</span> Element_Access <span class="hl opt">:=</span> Table<span class="hl opt">.</span>Get <span class="hl opt">(</span>Key<span class="hl opt">);</span>
                  <span class="hl kwa">begin</span>
                     <span class="hl kwa">if</span> Element <span class="hl opt">/=</span> <span class="hl kwa">null then</span>
                        Element<span class="hl opt">.</span><span class="hl kwa">all</span><span class="hl opt">.</span>Count <span class="hl opt">:=</span> <span class="hl kwb">Natural</span><span class="hl kwd">'Succ</span> <span class="hl opt">(</span>Element<span class="hl opt">.</span><span class="hl kwa">all</span><span class="hl opt">.</span>Count<span class="hl opt">);</span>
                     <span class="hl kwa">else</span>
                        Table<span class="hl opt">.</span>Set <span class="hl opt">(</span><span class="hl kwa">new</span> Element_Type<span class="hl str">'(Count =&gt; 1,</span>
<span class="hl str">                                                     Key =&gt; Key,</span>
<span class="hl str">                                                     Next =&gt; null));</span>
<span class="hl str">                     end if;</span>
<span class="hl str">                  end;</span>
<span class="hl str">               end loop;</span>
<span class="hl str">               return;</span>
<span class="hl str">            end Get_Frequencies;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">            function Count_Of (Element : not null Element_Access) return Natural is</span>
<span class="hl str">            begin</span>
<span class="hl str">               return Element.all.Count;</span>
<span class="hl str">            end Count_Of;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">            function Number_Counted (Nucleotide_Fragment : Fragment) return Natural is</span>
<span class="hl str">               The_Element : constant Element_Access := Table.Get (Nucleotide_Fragment);</span>
<span class="hl str">            begin</span>
<span class="hl str">               if The_Element /= null then</span>
<span class="hl str">                  return The_Element.all.Count;</span>
<span class="hl str">               else</span>
<span class="hl str">                  return 0;</span>
<span class="hl str">               end if;</span>
<span class="hl str">            end Number_Counted;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">            function Get_First return Element_Access is</span>
<span class="hl str">            begin</span>
<span class="hl str">               return Table.Get_First;</span>
<span class="hl str">            end Get_First;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">            function Get_Key (E : not null Element_Access) return Fragment is</span>
<span class="hl str">            begin</span>
<span class="hl str">               return E.all.Key;</span>
<span class="hl str">            end Get_Key;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">            function Get_Next return Element_Access is</span>
<span class="hl str">            begin</span>
<span class="hl str">               return Table.Get_Next;</span>
<span class="hl str">            end Get_Next;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">            procedure Get_Totals (Total : out Natural; Count : out Natural) is</span>
<span class="hl str">               The_Element : Element_Access := Table.Get_First;</span>
<span class="hl str">            begin</span>
<span class="hl str">               Total := 0;</span>
<span class="hl str">               Count := 0;</span>
<span class="hl str">               while The_Element /= null loop</span>
<span class="hl str">                  Total       := Total + The_Element.all.Count;</span>
<span class="hl str">                  Count       := Count + 1;</span>
<span class="hl str">                  The_Element := Table.Get_Next;</span>
<span class="hl str">               end loop;</span>
<span class="hl str">            end Get_Totals;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">            function Fragment_Of (Element : not null Element_Access) return Fragment is</span>
<span class="hl str">            begin</span>
<span class="hl str">               return Element.all.Key;</span>
<span class="hl str">            end Fragment_Of;</span>
<span class="hl str"></span>
<span class="hl str">            function Next (E : Element_Access) return Element_Access is</span>
<span class="hl str">            begin</span>
<span class="hl str">               return E.all.Next;</span>
<span class="hl str">            end Next;</span>
<span class="hl str"></span>
<span class="hl str">            procedure Set_Next (E : Element_Access; Next : Element_Access) is</span>
<span class="hl str">            begin</span>
<span class="hl str">               E.all.Next := Next;</span>
<span class="hl str">            end Set_Next;</span>
<span class="hl str"></span>
<span class="hl str">         end Calculator;</span>
<span class="hl str"></span>
<span class="hl str">      begin --  Write</span>
<span class="hl str"></span>
<span class="hl str">         Calculator.Get_Frequencies (Nucleotide_Length);</span>
<span class="hl str"></span>
<span class="hl str">         if Nucleotide_Fragment = Fragments.Null_Fragment then</span>
<span class="hl str">            Calculate_Total : declare</span>
<span class="hl str">               Num_Table_Entries : Natural;</span>
<span class="hl str">               Sum_Of_Counts     : Natural;</span>
<span class="hl str">            begin</span>
<span class="hl str">               Calculator.Get_Totals</span>
<span class="hl str">                 (Total =&gt; Sum_Of_Counts,</span>
<span class="hl str">                  Count =&gt; Num_Table_Entries);</span>
<span class="hl str"></span>
<span class="hl str">               Get_Sort_Put : declare</span>
<span class="hl str">                  Data : array (0 .. Num_Table_Entries) of Calculator.Element_Access;</span>
<span class="hl str"></span>
<span class="hl str">                  --  heap sort subprograms</span>
<span class="hl str">                  procedure Move (From : Natural; To : Natural);</span>
<span class="hl str">                  function Less_Then (Op1, Op2 : Natural) return Boolean;</span>
<span class="hl str"></span>
<span class="hl str">                  pragma Inline (Move, Less_Then);</span>
<span class="hl str"></span>
<span class="hl str">                  function Less_Then (Op1, Op2 : Natural) return Boolean is</span>
<span class="hl str">                  begin</span>
<span class="hl str">                     return</span>
<span class="hl str">                       Calculator.Count_Of (Data (Op1))</span>
<span class="hl str">                       &gt;</span>
<span class="hl str">                       Calculator.Count_Of (Data (Op2));</span>
<span class="hl str">                  end Less_Then;</span>
<span class="hl str"></span>
<span class="hl str">                  procedure Move (From : Natural; To : Natural) is</span>
<span class="hl str">                  begin</span>
<span class="hl str">                     Data (To) := Data (From);</span>
<span class="hl str">                  end Move;</span>
<span class="hl str"></span>
<span class="hl str">                  package Heap_Sort is new GNAT.Heap_Sort_G</span>
<span class="hl str">                    (Move =&gt; Move,</span>
<span class="hl str">                     Lt   =&gt; Less_Then);</span>
<span class="hl str"></span>
<span class="hl str">               begin  -- Get_Sort_Put</span>
<span class="hl str">                  Data (0) := null;</span>
<span class="hl str">                  Data (1) := Calculator.Get_First;</span>
<span class="hl str"></span>
<span class="hl str">                  for I in  2 .. Data'Last loop</span>
<span class="hl str">                     Data (I) := Calculator.Get_Next;</span>
<span class="hl str">                  end loop;</span>
<span class="hl str"></span>
<span class="hl str">                  Heap_Sort.Sort (Data'Last);</span>
<span class="hl str"></span>
<span class="hl str">                  Printer.Seize (Nucleotide_Length);</span>
<span class="hl str">                  for I in  1 .. Data'Last loop</span>
<span class="hl str">                     Ada.Text_IO.Put (Calculator.Fragment_Of (Data (I)) &amp; '</span> <span class="hl str">');</span>
<span class="hl str">                     Ada.Float_Text_IO.Put</span>
<span class="hl str">                       (Item =&gt; (100.0</span>
<span class="hl str">                                   * Float (Calculator.Count_Of (Data (I)))</span>
<span class="hl str">                                   / Float (Sum_Of_Counts)),</span>
<span class="hl str">                        Fore =&gt; 1,</span>
<span class="hl str">                        Aft  =&gt; 3,</span>
<span class="hl str">                        Exp  =&gt; 0);</span>
<span class="hl str">                     Ada.Text_IO.New_Line;</span>
<span class="hl str">                  end loop;</span>
<span class="hl str">                  Ada.Text_IO.New_Line;</span>
<span class="hl str">                  Printer.Release (Nucleotide_Length);</span>
<span class="hl str">               end Get_Sort_Put;</span>
<span class="hl str">            end Calculate_Total;</span>
<span class="hl str">         else</span>
<span class="hl str">            Printer.Seize (Nucleotide_Length);</span>
<span class="hl str">            Ada.Integer_Text_IO.Put</span>
<span class="hl str">              (Item =&gt; Calculator.Number_Counted (Nucleotide_Fragment),</span>
<span class="hl str">               Width =&gt; 1);</span>
<span class="hl str">            Ada.Text_IO.Put (Ada.Characters.Latin_1.HT);</span>
<span class="hl str">            Ada.Text_IO.Put_Line (Nucleotide_Fragment);</span>
<span class="hl str">            Printer.Release (Nucleotide_Length);</span>
<span class="hl str">         end if;</span>
<span class="hl str">      end Write;</span>
<span class="hl str"></span>
<span class="hl str">      task body Writer is</span>
<span class="hl str">         Current_Length   : Fragment_Lengths;</span>
<span class="hl str">         Current_Fragment : Fragments.Fragment;</span>
<span class="hl str"></span>
<span class="hl str">         use Fragments;</span>
<span class="hl str">      begin</span>
<span class="hl str">         loop</span>
<span class="hl str">            --</span>
<span class="hl str">            --  perform a `Write` with parameters `Set` or terminate</span>
<span class="hl str">            --</span>
<span class="hl str">            select</span>
<span class="hl str">               accept Set (Nucleotide_Length   : in Fragment_Lengths;</span>
<span class="hl str">                           Nucleotide_Fragment : in Fragment := Null_Fragment)</span>
<span class="hl str">               do</span>
<span class="hl str">                  Current_Length   := Nucleotide_Length;</span>
<span class="hl str">                  Current_Fragment := Nucleotide_Fragment;</span>
<span class="hl str">               end Set;</span>
<span class="hl str">               Write (Current_Length, Current_Fragment);</span>
<span class="hl str">            or</span>
<span class="hl str">               terminate;</span>
<span class="hl str">            end select;</span>
<span class="hl str">         end loop;</span>
<span class="hl str">      exception</span>
<span class="hl str">         when E : others =&gt;</span>
<span class="hl str">            Ada.Text_IO.Put_Line(Ada.Text_IO.Current_Error,</span>
<span class="hl str">              Ada.Exceptions.Exception_Information(E));</span>
<span class="hl str">      end Writer;</span>
<span class="hl str"></span>
<span class="hl str">   end Work;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">   package Fragments_1 is new String_Fragments (1);</span>
<span class="hl str">   package Fragments_2 is new String_Fragments (2);</span>
<span class="hl str">   package Fragments_3 is new String_Fragments (3);</span>
<span class="hl str">   package Fragments_4 is new String_Fragments (4);</span>
<span class="hl str">   package Fragments_6 is new String_Fragments (6);</span>
<span class="hl str">   package Fragments_12 is new String_Fragments (12);</span>
<span class="hl str">   package Fragments_18 is new String_Fragments (18);</span>
<span class="hl str"></span>
<span class="hl str">   --  List of fragments to be analyzed for this test:</span>
<span class="hl str"></span>
<span class="hl str">   Fragment_3  : constant Fragments_3.Fragment := Fragments_3.To_Fragment (&quot;GGT&quot;);</span>
<span class="hl str">   Fragment_4  : constant Fragments_4.Fragment := Fragments_4.To_Fragment (&quot;GGTA&quot;);</span>
<span class="hl str">   Fragment_6  : constant Fragments_6.Fragment := Fragments_6.To_Fragment (&quot;GGTATT&quot;);</span>
<span class="hl str">   Fragment_12 : constant Fragments_12.Fragment := Fragments_12.To_Fragment (&quot;GGTATTTTAATT&quot;);</span>
<span class="hl str">   Fragment_18 : constant Fragments_18.Fragment := Fragments_18.To_Fragment (&quot;GGTATTTTAATTTATAGT&quot;);</span>
<span class="hl str"></span>
<span class="hl str">   package Work_On_1 is new Work (Fragments_1);</span>
<span class="hl str">   package Work_On_2 is new Work (Fragments_2);</span>
<span class="hl str">   package Work_On_3 is new Work (Fragments_3);</span>
<span class="hl str">   package Work_On_4 is new Work (Fragments_4);</span>
<span class="hl str">   package Work_On_6 is new Work (Fragments_6);</span>
<span class="hl str">   package Work_On_12 is new Work (Fragments_12);</span>
<span class="hl str">   package Work_On_18 is new Work (Fragments_18);</span>
<span class="hl str"></span>
<span class="hl str">begin</span>
<span class="hl str">   Work_On_1.Writer.Set (1);</span>
<span class="hl str">   Work_On_12.Writer.Set (Fragment_12'Length, Fragment_12);</span>
<span class="hl str">   Work_On_18.Writer.Set (Fragment_18'Length, Fragment_18);</span>
<span class="hl str">   Work_On_6.Writer.Set (Fragment_6'Length, Fragment_6);</span>
<span class="hl str">   Work_On_2.Writer.Set (2);</span>
<span class="hl str">   Work_On_4.Writer.Set (Fragment_4'Length, Fragment_4);</span>
<span class="hl str">   Work_On_3.Writer.Set (Fragment_3'Length, Fragment_3);</span>
<span class="hl str">end KNucleotide;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">generic</span>
<span class="hl str">   Max_String_Length : Positive;</span>
<span class="hl str">package String_Fragments is</span>
<span class="hl str"></span>
<span class="hl str">   subtype Fragment is String (1 .. Max_String_Length);</span>
<span class="hl str"></span>
<span class="hl str">   function To_Fragment (Source : String) return Fragment;</span>
<span class="hl str">   function Null_Fragment return Fragment;</span>
<span class="hl str">   function &quot;=&quot; (Left, Right: Fragment) return Boolean;</span>
<span class="hl str"></span>
<span class="hl str">end String_Fragments;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">with Ada.Unchecked_Conversion;</span>
<span class="hl str"></span>
<span class="hl str">package body String_Fragments is</span>
<span class="hl str"></span>
<span class="hl str">   Bytes_Per_Word : constant := 4;</span>
<span class="hl str">   type Uns is mod 2**(8 * Bytes_Per_Word);</span>
<span class="hl str">   for Uns'Size use 8 * Bytes_Per_Word;</span>
<span class="hl str">   subtype Str is String (1 .. Bytes_Per_Word);</span>
<span class="hl str"></span>
<span class="hl str">   function Null_Fragment return Fragment is</span>
<span class="hl str">   begin</span>
<span class="hl str">      return Fragment'</span><span class="hl opt">(</span><span class="hl num">1</span> <span class="hl opt">..</span> Max_String_Length <span class="hl opt">=&gt;</span> <span class="hl str">'*'</span><span class="hl opt">);</span>
   <span class="hl kwa">end</span> Null_Fragment<span class="hl opt">;</span>


   <span class="hl kwa">function</span> To_Uns <span class="hl kwa">is new</span> Ada<span class="hl opt">.</span>Unchecked_Conversion <span class="hl opt">(</span>Str<span class="hl opt">,</span> Uns<span class="hl opt">);</span>

   <span class="hl kwa">function</span> <span class="hl str">&quot;=&quot;</span> <span class="hl opt">(</span>Left<span class="hl opt">,</span> Right<span class="hl opt">:</span> Fragment<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl kwb">Boolean</span> <span class="hl kwa">is</span>
      Strt <span class="hl opt">:</span> <span class="hl kwb">Integer</span> <span class="hl opt">:=</span> <span class="hl num">1</span><span class="hl opt">;</span>
      Fnsh <span class="hl opt">:</span> <span class="hl kwb">Integer</span> <span class="hl opt">:=</span> Bytes_Per_Word<span class="hl opt">;</span>
      Last <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">Integer</span> <span class="hl opt">:=</span> Left<span class="hl kwd">'Last</span><span class="hl opt">;</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">if</span> Last <span class="hl opt">/=</span> Right<span class="hl kwd">'Last</span> <span class="hl kwa">then</span>
         <span class="hl kwa">return</span> <span class="hl kwd">False</span><span class="hl opt">;</span>
      <span class="hl kwa">end if</span><span class="hl opt">;</span>

      <span class="hl kwa">loop</span>
         <span class="hl kwa">exit when</span> Fnsh <span class="hl opt">&gt;</span> Last<span class="hl opt">;</span>
         <span class="hl kwa">if</span> To_Uns <span class="hl opt">(</span>Left<span class="hl opt">(</span>Strt<span class="hl opt">..</span>Fnsh<span class="hl opt">)) /=</span> To_Uns <span class="hl opt">(</span>Right<span class="hl opt">(</span>Strt<span class="hl opt">..</span>Fnsh<span class="hl opt">))</span> <span class="hl kwa">then</span>
            <span class="hl kwa">return</span> <span class="hl kwd">False</span><span class="hl opt">;</span>
         <span class="hl kwa">end if</span><span class="hl opt">;</span>
         Strt <span class="hl opt">:=</span> Strt <span class="hl opt">+</span> Bytes_Per_Word<span class="hl opt">;</span>
         Fnsh <span class="hl opt">:=</span> Fnsh <span class="hl opt">+</span> Bytes_Per_Word<span class="hl opt">;</span>
      <span class="hl kwa">end loop</span><span class="hl opt">;</span>

      <span class="hl kwa">for</span> I <span class="hl kwa">in</span> Strt <span class="hl opt">..</span> Last <span class="hl kwa">loop</span>
         <span class="hl kwa">if</span> Left<span class="hl opt">(</span>I<span class="hl opt">) /=</span> Right<span class="hl opt">(</span>I<span class="hl opt">)</span> <span class="hl kwa">then</span>
            <span class="hl kwa">return</span> <span class="hl kwd">False</span><span class="hl opt">;</span>
         <span class="hl kwa">end if</span><span class="hl opt">;</span>
      <span class="hl kwa">end loop</span><span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl kwd">True</span><span class="hl opt">;</span>
   <span class="hl kwa">end</span> <span class="hl str">&quot;=&quot;</span><span class="hl opt">;</span>


   <span class="hl kwa">function</span> To_Fragment <span class="hl opt">(</span>Source <span class="hl opt">:</span> <span class="hl kwb">String</span><span class="hl opt">)</span> <span class="hl kwa">return</span> Fragment <span class="hl kwa">is</span>
      Result <span class="hl opt">:</span> Fragment<span class="hl opt">;</span>
   <span class="hl kwa">begin</span>
      <span class="hl kwa">if</span> Source<span class="hl kwd">'Length</span> <span class="hl opt">/=</span> Max_String_Length <span class="hl kwa">then</span>
         <span class="hl kwa">raise</span> Constraint_Error<span class="hl opt">;</span>
      <span class="hl kwa">end if</span><span class="hl opt">;</span>
      Result <span class="hl opt">(</span><span class="hl num">1</span> <span class="hl opt">..</span> Source<span class="hl kwd">'Length</span><span class="hl opt">) :=</span> Source<span class="hl opt">;</span>
      <span class="hl kwa">return</span> Result<span class="hl opt">;</span>
   <span class="hl kwa">end</span> To_Fragment<span class="hl opt">;</span>

<span class="hl kwa">end</span> String_Fragments<span class="hl opt">;</span>


<span class="hl slc">----------------</span>
<span class="hl slc">-- data input --</span>
<span class="hl slc">----------------</span>

<span class="hl kwa">package</span> Data_Input <span class="hl kwa">is</span>

   <span class="hl slc">--  Read data from Standard_Input and return section THREE as String:</span>

   <span class="hl kwa">function</span> Read <span class="hl kwa">return</span> <span class="hl kwb">String</span><span class="hl opt">;</span>

<span class="hl kwa">end</span> Data_Input<span class="hl opt">;</span>

<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Strings<span class="hl opt">.</span>Maps<span class="hl opt">.</span>Constants<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>IO_Exceptions<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Strings<span class="hl opt">.</span>Unbounded<span class="hl opt">;</span>
<span class="hl kwa">with</span> Line_IO<span class="hl opt">;</span>
<span class="hl kwa">with</span> Ada<span class="hl opt">.</span>Unchecked_Deallocation<span class="hl opt">;</span>

<span class="hl kwa">package body</span> Data_Input <span class="hl kwa">is</span>

   <span class="hl kwa">use</span> Ada<span class="hl opt">.</span>Strings<span class="hl opt">;</span>
   UnixLF <span class="hl opt">:</span> <span class="hl kwa">constant</span> <span class="hl kwb">String</span> <span class="hl opt">:=</span> <span class="hl kwb">String</span><span class="hl str">'(1 =&gt; ASCII.LF);</span>
<span class="hl str">   package LIO is new Line_IO (UnixLF);</span>
<span class="hl str"></span>
<span class="hl str">   Data_Buffer : Unbounded.Unbounded_String := Unbounded.Null_Unbounded_String;</span>
<span class="hl str"></span>
<span class="hl str">   Section_Marker : constant Character := '</span><span class="hl opt">&gt;</span><span class="hl str">';</span>
<span class="hl str">   Section        : constant String    := Section_Marker &amp; &quot;THREE&quot;;</span>
<span class="hl str"></span>
<span class="hl str">   --  Read next data section - until EOF oder a line beginning with &gt; is found.</span>
<span class="hl str"></span>
<span class="hl str">   type String_Access is access String;</span>
<span class="hl str">   procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);</span>
<span class="hl str"></span>
<span class="hl str">   procedure Read_Section is</span>
<span class="hl str">      Buffer     : String_Access;</span>
<span class="hl str">      Read_First : Natural;</span>
<span class="hl str">      Read_Last  : Natural;</span>
<span class="hl str">   begin</span>
<span class="hl str">      Buffer := new String (1 .. 1024 * 1024 * 16);</span>
<span class="hl str">      Get_Data : loop</span>
<span class="hl str">         Read_First := Buffer'First;</span>
<span class="hl str">         Read_Last  := Buffer'First - 1;</span>
<span class="hl str">         -- fill Buffer and append to Data_Buffer when filled</span>
<span class="hl str">         loop</span>
<span class="hl str">            declare</span>
<span class="hl str">               Line : String renames LIO.Get_Line;</span>
<span class="hl str">            begin</span>
<span class="hl str">               Read_Last := Read_First + Line'Length - 1;</span>
<span class="hl str">               if Read_Last &gt;= Buffer'Last then</span>
<span class="hl str">                  Unbounded.Append</span>
<span class="hl str">                    (Data_Buffer, New_Item =&gt; Buffer(1 .. Read_First - 1));</span>
<span class="hl str">                  Unbounded.Append (Data_Buffer, New_Item =&gt; Line);</span>
<span class="hl str">                  exit;</span>
<span class="hl str">               end if;</span>
<span class="hl str">               Buffer (Read_First .. Read_Last) := Line;</span>
<span class="hl str">            end;</span>
<span class="hl str">            exit Get_Data when Buffer (Read_First) = Section_Marker;</span>
<span class="hl str">            Read_First := Read_Last + 1;</span>
<span class="hl str">         end loop;</span>
<span class="hl str">      end loop Get_Data;</span>
<span class="hl str">      Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));</span>
<span class="hl str">      Free (Buffer);</span>
<span class="hl str">   exception</span>
<span class="hl str">      when Ada.IO_Exceptions.End_Error =&gt;</span>
<span class="hl str">         Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));</span>
<span class="hl str">         Free (Buffer);</span>
<span class="hl str">   end Read_Section;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">   --  Skip data on Standard_Input until &quot;&gt;THREE&quot; is found</span>
<span class="hl str"></span>
<span class="hl str">   procedure Skip_To_Section is</span>
<span class="hl str">   begin</span>
<span class="hl str">      loop</span>
<span class="hl str">         declare</span>
<span class="hl str">            Line : constant String := LIO.Get_Line;</span>
<span class="hl str">         begin</span>
<span class="hl str">            exit when Line(1) = Section(1)</span>
<span class="hl str">              and then Line(Section'Range) = Section;</span>
<span class="hl str">         end;</span>
<span class="hl str">      end loop;</span>
<span class="hl str">   end Skip_To_Section;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">   function Read return String is</span>
<span class="hl str">   begin</span>
<span class="hl str">      Skip_To_Section;</span>
<span class="hl str">      Read_Section;</span>
<span class="hl str"></span>
<span class="hl str">      Unbounded.Translate</span>
<span class="hl str">        (Source =&gt; Data_Buffer,</span>
<span class="hl str">         Mapping =&gt; Maps.Constants.Upper_Case_Map);</span>
<span class="hl str"></span>
<span class="hl str">      return Unbounded.To_String (Data_Buffer);</span>
<span class="hl str">   end Read;</span>
<span class="hl str"></span>
<span class="hl str">end Data_Input;</span>
<span class="hl str"></span>
<span class="hl str">---------------------------</span>
<span class="hl str">--  Stream I/O of lines --</span>
<span class="hl str">---------------------------</span>
<span class="hl str">generic</span>
<span class="hl str">   Separator_Sequence : in String;  --  ends a line</span>
<span class="hl str">package Line_IO is</span>
<span class="hl str"></span>
<span class="hl str">   pragma Elaborate_Body;</span>
<span class="hl str"></span>
<span class="hl str">   procedure Put_Line (Item : String) is null;</span>
<span class="hl str">   -- not used in this program</span>
<span class="hl str"></span>
<span class="hl str">   function Get_Line return String;</span>
<span class="hl str"></span>
<span class="hl str">end Line_IO;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">with Ada.Streams.Stream_IO;</span>
<span class="hl str"></span>
<span class="hl str">package body Line_IO is</span>
<span class="hl str"></span>
<span class="hl str">   use Ada.Streams;</span>
<span class="hl str"></span>
<span class="hl str">   Stdin : Stream_IO.File_Type;</span>
<span class="hl str"></span>
<span class="hl str">   -- Types etc., status variables, and the buffer.</span>
<span class="hl str"></span>
<span class="hl str">   BUFSIZ: constant := 8_192;</span>
<span class="hl str">   pragma Assert(Character'Size = Stream_Element'Size);</span>
<span class="hl str"></span>
<span class="hl str">   SL : constant Natural := Separator_Sequence'Length;</span>
<span class="hl str"></span>
<span class="hl str">   subtype Extended_Buffer_Index is Positive range 1 .. BUFSIZ + SL;</span>
<span class="hl str">   subtype Buffer_Index is Extended_Buffer_Index</span>
<span class="hl str">     range Extended_Buffer_Index'First .. Extended_Buffer_Index'Last - SL;</span>
<span class="hl str">   subtype Extended_Bytes_Index is Stream_Element_Offset</span>
<span class="hl str">     range 1 .. Stream_Element_Offset(Extended_Buffer_Index'Last);</span>
<span class="hl str">   subtype Bytes_Index is Extended_Bytes_Index</span>
<span class="hl str">     range Extended_Bytes_Index'First</span>
<span class="hl str">     .. (Extended_Bytes_Index'Last - Stream_Element_Offset(SL));</span>
<span class="hl str"></span>
<span class="hl str">   subtype Buffer_Data is String(Extended_Buffer_Index);</span>
<span class="hl str">   subtype Buffer_Bytes is Stream_Element_Array(Extended_Bytes_Index);</span>
<span class="hl str"></span>
<span class="hl str">   Buffer : Buffer_Data;</span>
<span class="hl str">   Bytes  : Buffer_Bytes;</span>
<span class="hl str">   for Bytes'Address use Buffer'Address;</span>
<span class="hl str">   pragma Import (Ada, Bytes);</span>
<span class="hl str"></span>
<span class="hl str">   -- start of next substring and last valid character in buffer</span>
<span class="hl str">   Position : Natural range 0 .. Extended_Buffer_Index'Last;</span>
<span class="hl str">   Last     : Natural range 0 .. Buffer_Index'Last;</span>
<span class="hl str">   End_Of_Input : Boolean;</span>
<span class="hl str"></span>
<span class="hl str">   function Get_Line return String is</span>
<span class="hl str"></span>
<span class="hl str">      procedure Reload is</span>
<span class="hl str">         --  fill Buffer with bytes available</span>
<span class="hl str">         Last_Filled : Stream_Element_Offset;</span>
<span class="hl str">      begin</span>
<span class="hl str">         if Last &lt; Buffer_Index'Last then</span>
<span class="hl str">            raise Stream_IO.End_Error;</span>
<span class="hl str">         end if;</span>
<span class="hl str">         Stream_IO.Read(Stdin,</span>
<span class="hl str">           Item =&gt; Bytes(Bytes_Index),</span>
<span class="hl str">           Last =&gt; Last_Filled);</span>
<span class="hl str">         Last := Natural(Last_Filled);</span>
<span class="hl str">         Position := 1;</span>
<span class="hl str">         Buffer(Last + 1 .. Last + SL) := Separator_Sequence;</span>
<span class="hl str">      end Reload;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">      function Separator_Position return Natural is</span>
<span class="hl str">         --   index of next Separator_Sequence (may be sentinel)</span>
<span class="hl str">         pragma Inline(Separator_Position);</span>
<span class="hl str">         K : Extended_Buffer_Index := Position;</span>
<span class="hl str">      begin</span>
<span class="hl str">         while Buffer(K) /= Separator_Sequence(1) loop</span>
<span class="hl str">            K := K + 1;</span>
<span class="hl str">         end loop;</span>
<span class="hl str">         return K;</span>
<span class="hl str">      end Separator_Position;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">      Next_Separator : Natural range 0 .. Extended_Buffer_Index'Last;</span>
<span class="hl str">   begin  -- Get_Line</span>
<span class="hl str"></span>
<span class="hl str">      if End_Of_Input then</span>
<span class="hl str">         raise Stream_IO.End_Error;</span>
<span class="hl str">      end if;</span>
<span class="hl str"></span>
<span class="hl str">      Next_Separator := Separator_Position;</span>
<span class="hl str"></span>
<span class="hl str">      if Next_Separator &gt; Last then</span>
<span class="hl str">         declare</span>
<span class="hl str">            Result : constant String := Buffer(Position .. Last);</span>
<span class="hl str">            subtype XString is String (1 .. Last - Position + 1);</span>
<span class="hl str">         begin</span>
<span class="hl str">            begin</span>
<span class="hl str">               Reload;</span>
<span class="hl str">               return XString(Result) &amp; Get_Line;</span>
<span class="hl str">            exception</span>
<span class="hl str">               when Stream_IO.End_Error =&gt;</span>
<span class="hl str">                  End_Of_Input := True;</span>
<span class="hl str">                  return XString(Result);</span>
<span class="hl str">            end;</span>
<span class="hl str">         end;</span>
<span class="hl str">      else</span>
<span class="hl str">         declare</span>
<span class="hl str">            Result : String renames Buffer(Position .. Next_Separator - 1);</span>
<span class="hl str">            subtype XString is String (1 .. Next_Separator - Position);</span>
<span class="hl str">         begin</span>
<span class="hl str">            Position := Next_Separator + SL;</span>
<span class="hl str">            return XString (Result);</span>
<span class="hl str">         end;</span>
<span class="hl str">      end if;</span>
<span class="hl str"></span>
<span class="hl str">      raise Program_Error;</span>
<span class="hl str">   end Get_Line;</span>
<span class="hl str"></span>
<span class="hl str"></span>
<span class="hl str">begin</span>
<span class="hl str">   Stream_IO.Open (Stdin,</span>
<span class="hl str">     Mode =&gt; Stream_IO.In_File,</span>
<span class="hl str">     Name =&gt; &quot;/dev/stdin&quot;);</span>
<span class="hl str"></span>
<span class="hl str">   Buffer(Buffer_Index'Last + 1 .. Buffer'Last) := Separator_Sequence;</span>
<span class="hl str">   Position := Buffer_Index'Last + 1;</span>
<span class="hl str">   Last := Buffer_Index'Last;</span>
<span class="hl str">   End_Of_Input := False;</span>
<span class="hl str">end Line_IO;</span>
